[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 HicAggR authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"/articles/HicAggR.html","id":"installation","dir":"Articles","previous_headings":"Requirements","what":"Installation","title":"HicAggR - Quick start","text":"","code":"remotes::install_github(\"CuvierLab/HicAggR\")"},{"path":"/articles/HicAggR.html","id":"load-library","dir":"Articles","previous_headings":"Requirements","what":"Load library","title":"HicAggR - Quick start","text":"","code":"library(HicAggR) #> Warning: replacing previous import 'S4Arrays::makeNindexFromArrayViewport' by #> 'DelayedArray::makeNindexFromArrayViewport' when loading 'SummarizedExperiment'"},{"path":[]},{"path":"/articles/HicAggR.html","id":"description","dir":"Articles","previous_headings":"Test dataset","what":"Description","title":"HicAggR - Quick start","text":"Data obtained Drosophila melanogaster S2 cells. HiC test dataset: Directly downloaded 4DN platform. Genomic coordinates: ChIPseq peaks Beaf-32 protein wild type cells (GSM1278639).","code":""},{"path":"/articles/HicAggR.html","id":"genomic-3d-structure","dir":"Articles","previous_headings":"Test dataset","what":"Genomic 3D structure","title":"HicAggR - Quick start","text":"test, please download HiC data .hic format (Juicer).","code":"options(timeout = 3600)  temp.dir <- file.path(tempdir(), \"HIC_DATA\") dir.create(temp.dir)  Hic.url <- paste0(\"https://4dn-open-data-public.s3.amazonaws.com/\", \"fourfront-webprod/wfoutput/7386f953-8da9-47b0-acb2-931cba810544/\", \"4DNFIOTPSS3L.hic\") HicOutput.pth <- file.path(temp.dir, \"Control_HIC.hic\") HicOutput.pth <- normalizePath(HicOutput.pth) #> Warning in normalizePath(HicOutput.pth): #> path[1]=\"/tmp/RtmpFnsi1c/HIC_DATA/Control_HIC.hic\": No such file or directory if(.Platform$OS.type == \"windows\"){     download.file(Hic.url, HicOutput.pth, method = 'auto',         extra = '-k',mode=\"wb\") }else{     download.file(Hic.url, HicOutput.pth, method = 'auto', extra = '-k') }"},{"path":"/articles/HicAggR.html","id":"genomic-location-and-annotation-data","dir":"Articles","previous_headings":"Test dataset","what":"Genomic location and annotation data","title":"HicAggR - Quick start","text":"kind data can imported R rtracklayer package.","code":"data(\"Beaf32_Peaks.gnr\")"},{"path":"/articles/HicAggR.html","id":"additional-genome-informations","dir":"Articles","previous_headings":"Test dataset","what":"Additional genome informations","title":"HicAggR - Quick start","text":"Required genomic information used functions entire pipeline data.frame containing chromosomes names sized binSize, corresponding HiC matrices resolution.","code":"seqlengths.num <- c('2L'=23513712, '2R'=25286936) chromSizes  <- data.frame(     seqnames   = names(seqlengths.num ),      seqlengths = seqlengths.num     ) binSize <- 1000"},{"path":"/articles/HicAggR.html","id":"import-hic","dir":"Articles","previous_headings":"","what":"1 Import HiC","title":"HicAggR - Quick start","text":"package supports import normalization HiC data. NOTE: Since version 0.99.2, package supports import balanced HiC matrices .hic, .cool/.mcool formats. also supports import ‘o/e’ matrices .hic format.","code":""},{"path":"/articles/HicAggR.html","id":"import","dir":"Articles","previous_headings":"1 Import HiC","what":"Import","title":"HicAggR - Quick start","text":"HicAggR can import HiC data stored main formats: .hic, .cool, .mcool, .h5. pacakage imports default raw counts R. Therefore, necessary perform balancing observed/expected correction steps.","code":"hicLst <- ImportHiC(     file      = HicOutput.pth,     hicResolution       = binSize,     chrom_1   = c(\"2L\", \"2R\")     )"},{"path":"/articles/HicAggR.html","id":"balancing","dir":"Articles","previous_headings":"1 Import HiC","what":"Balancing","title":"HicAggR - Quick start","text":"","code":"hicLst <- BalanceHiC(hicLst)"},{"path":"/articles/HicAggR.html","id":"observedexpected-correction","dir":"Articles","previous_headings":"1 Import HiC","what":"Observed/Expected Correction","title":"HicAggR - Quick start","text":"","code":"hicLst <- OverExpectedHiC(hicLst)"},{"path":"/articles/HicAggR.html","id":"import-genomic-coordinates","dir":"Articles","previous_headings":"","what":"2 Import genomic coordinates","title":"HicAggR - Quick start","text":"Genomic coordinates data (ChIP seq peaks feature) need indexed using referenced genome HiC data. genomic coordinates paired GInteraction objects.","code":""},{"path":"/articles/HicAggR.html","id":"features-indexing","dir":"Articles","previous_headings":"2 Import genomic coordinates","what":"Features Indexing","title":"HicAggR - Quick start","text":"","code":"Beaf_Index.gnr <- IndexFeatures(     gRangeList        = list(Beaf = Beaf32_Peaks.gnr),     chromSizes         = chromSizes,     binSize           = binSize     )"},{"path":"/articles/HicAggR.html","id":"beaf32---beaf32-putatives","dir":"Articles","previous_headings":"2 Import genomic coordinates","what":"Beaf32 <-> Beaf32 putatives","title":"HicAggR - Quick start","text":"Constraints distance interaction sites defined order limit number pairs.","code":"Beaf_Pairs.gni <- SearchPairs(     indexAnchor = Beaf_Index.gnr,     minDist     = \"25KB\",     maxDist     = \"100KB\"     )"},{"path":"/articles/HicAggR.html","id":"submatrices-extractions","dir":"Articles","previous_headings":"","what":"3 Submatrices extractions","title":"HicAggR - Quick start","text":"data imported, interactions extracted pairs genomic coordinates.","code":""},{"path":"/articles/HicAggR.html","id":"extraction","dir":"Articles","previous_headings":"3 Submatrices extractions","what":"Extraction","title":"HicAggR - Quick start","text":"","code":"Beaf.mtx_lst <- ExtractSubmatrix(     genomicFeature  = Beaf_Pairs.gni,     hicLst = hicLst     )"},{"path":"/articles/HicAggR.html","id":"plot-and-visualization","dir":"Articles","previous_headings":"","what":"4 Plot and visualization","title":"HicAggR - Quick start","text":"Submatrices aggregated sum, average median. , aggregated matrix plotted heatmap contact frequencies (example, contacts surounding Beaf-32 sites).","code":""},{"path":"/articles/HicAggR.html","id":"prepare-matrices-list","dir":"Articles","previous_headings":"4 Plot and visualization","what":"Prepare matrices list","title":"HicAggR - Quick start","text":"","code":"Beaf.mtx_lst <- PrepareMtxList(     matrices = Beaf.mtx_lst )"},{"path":"/articles/HicAggR.html","id":"aggregation","dir":"Articles","previous_headings":"4 Plot and visualization","what":"Aggregation","title":"HicAggR - Quick start","text":"","code":"aggreg.mtx <- Aggregation(Beaf.mtx_lst)"},{"path":"/articles/HicAggR.html","id":"visualisation","dir":"Articles","previous_headings":"4 Plot and visualization","what":"Visualisation","title":"HicAggR - Quick start","text":"","code":"ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA Beaf <-> Beaf\"     )"},{"path":"/articles/HicAggR.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"HicAggR - Quick start","text":"","code":"sessionInfo() #> R version 4.3.3 (2024-02-29) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] HicAggR_0.99.3 #>  #> loaded via a namespace (and not attached): #>  [1] SummarizedExperiment_1.32.0 gtable_0.3.4                #>  [3] xfun_0.43                   bslib_0.6.2                 #>  [5] ggplot2_3.5.0               rhdf5_2.46.1                #>  [7] Biobase_2.62.0              lattice_0.22-5              #>  [9] rhdf5filters_1.14.1         vctrs_0.6.5                 #> [11] tools_4.3.3                 bitops_1.0-7                #> [13] generics_0.1.3              parallel_4.3.3              #> [15] stats4_4.3.3                tibble_3.2.1                #> [17] fansi_1.0.6                 highr_0.10                  #> [19] pkgconfig_2.0.3             Matrix_1.6-5                #> [21] data.table_1.15.2           desc_1.4.3                  #> [23] S4Vectors_0.40.2            lifecycle_1.0.4             #> [25] GenomeInfoDbData_1.2.11     farver_2.1.1                #> [27] stringr_1.5.1               compiler_4.3.3              #> [29] textshaping_0.3.7           munsell_0.5.0               #> [31] codetools_0.2-19            InteractionSet_1.30.0       #> [33] GenomeInfoDb_1.38.8         htmltools_0.5.8             #> [35] sass_0.4.9                  RCurl_1.98-1.14             #> [37] yaml_2.3.8                  tidyr_1.3.1                 #> [39] pkgdown_2.0.7               pillar_1.9.0                #> [41] crayon_1.5.2                jquerylib_0.1.4             #> [43] BiocParallel_1.36.0         DelayedArray_0.28.0         #> [45] cachem_1.0.8                abind_1.4-5                 #> [47] tidyselect_1.2.1            digest_0.6.35               #> [49] stringi_1.8.3               dplyr_1.1.4                 #> [51] purrr_1.0.2                 labeling_0.4.3              #> [53] fastmap_1.1.1               grid_4.3.3                  #> [55] colorspace_2.1-0            cli_3.6.2                   #> [57] SparseArray_1.2.4           magrittr_2.0.3              #> [59] S4Arrays_1.2.1              utf8_1.2.4                  #> [61] withr_3.0.0                 scales_1.3.0                #> [63] rmarkdown_2.26              XVector_0.42.0              #> [65] matrixStats_1.2.0           gridExtra_2.3               #> [67] ragg_1.3.0                  memoise_2.0.1               #> [69] evaluate_0.23               knitr_1.45                  #> [71] GenomicRanges_1.54.1        IRanges_2.36.0              #> [73] rlang_1.1.3                 Rcpp_1.0.12                 #> [75] glue_1.7.0                  BiocGenerics_0.48.1         #> [77] reshape_0.8.9               jsonlite_1.8.8              #> [79] strawr_0.0.91               Rhdf5lib_1.24.2             #> [81] plyr_1.8.9                  R6_2.5.1                    #> [83] MatrixGenerics_1.14.0       systemfonts_1.0.6           #> [85] fs_1.6.3                    zlibbioc_1.48.2"},{"path":[]},{"path":"/articles/InDepth.html","id":"installation","dir":"Articles","previous_headings":"Requirements","what":"Installation","title":"HicAggR - In depth tutorial","text":"","code":"remotes::install_github(\"CuvierLab/HicAggR\")"},{"path":"/articles/InDepth.html","id":"load-library","dir":"Articles","previous_headings":"Requirements","what":"Load library","title":"HicAggR - In depth tutorial","text":"","code":"library(HicAggR) #> Warning: replacing previous import 'S4Arrays::makeNindexFromArrayViewport' by #> 'DelayedArray::makeNindexFromArrayViewport' when loading 'SummarizedExperiment'"},{"path":[]},{"path":"/articles/InDepth.html","id":"description","dir":"Articles","previous_headings":"Test dataset","what":"Description","title":"HicAggR - In depth tutorial","text":"Data obtained Drosophila melanogaster S2 cells. 1. HiC test dataset Directly downloaded 4DN platform. * Control Condition * Heat Shock Condition 2. Genomic coordinates: * ChIPseq peaks Beaf-32 protein wild type cells (GSM1278639). * Reference annotation data TSS UCSC database. * Topologically associating domains (TAD) annotations defined described (F. Ramirez, 2018).","code":""},{"path":"/articles/InDepth.html","id":"genomic-3d-structure","dir":"Articles","previous_headings":"Test dataset","what":"1. Genomic 3D structure","title":"HicAggR - In depth tutorial","text":"test, please download HiC data .hic format (Juicer) .mcool format (HiCExplorer). Examples format provided .","code":""},{"path":"/articles/InDepth.html","id":"temp-directory-preparation","dir":"Articles","previous_headings":"Test dataset > 1. Genomic 3D structure","what":"Temp directory preparation","title":"HicAggR - In depth tutorial","text":"","code":"options(timeout = 3600) temp.dir <- file.path(tempdir(), \"HIC_DATA\") dir.create(temp.dir)"},{"path":"/articles/InDepth.html","id":"control-condition--hic-file","dir":"Articles","previous_headings":"Test dataset > 1. Genomic 3D structure","what":"Control condition (.hic File)","title":"HicAggR - In depth tutorial","text":"","code":"Hic.url <- paste0(\"https://4dn-open-data-public.s3.amazonaws.com/\", \"fourfront-webprod/wfoutput/7386f953-8da9-47b0-acb2-931cba810544/\", \"4DNFIOTPSS3L.hic\") HicOutput.pth <- file.path(temp.dir, \"Control_HIC.hic\") HicOutput.pth <- normalizePath(HicOutput.pth) #> Warning in normalizePath(HicOutput.pth): #> path[1]=\"/tmp/RtmpUzk5vb/HIC_DATA/Control_HIC.hic\": No such file or directory if(.Platform$OS.type == \"windows\"){     download.file(Hic.url, HicOutput.pth, method = \"auto\",         extra = \"-k\", mode=\"wb\") }else{     download.file(Hic.url, HicOutput.pth, method = \"auto\",         extra = \"-k\") }"},{"path":"/articles/InDepth.html","id":"heat-shock-condition--mcool-file","dir":"Articles","previous_headings":"Test dataset > 1. Genomic 3D structure","what":"Heat shock condition (.mcool File)","title":"HicAggR - In depth tutorial","text":"","code":"Mcool.url <- paste0(\"https://4dn-open-data-public.s3.amazonaws.com/\", \"fourfront-webprod/wfoutput/4f1479a2-4226-4163-ba99-837f2c8f4ac0/\", \"4DNFI8DRD739.mcool\") McoolOutput.pth <- file.path(temp.dir, \"HeatShock_HIC.mcool\") McoolOutput.pth <- normalizePath(McoolOutput.pth) #> Warning in normalizePath(McoolOutput.pth): #> path[1]=\"/tmp/RtmpUzk5vb/HIC_DATA/HeatShock_HIC.mcool\": No such file or #> directory if(.Platform$OS.type == \"windows\"){     download.file(Mcool.url, McoolOutput.pth, method = \"auto\",         extra = \"-k\", mode=\"wb\") }else{     download.file(Mcool.url, McoolOutput.pth, method = \"auto\", extra = \"-k\") }"},{"path":"/articles/InDepth.html","id":"genomic-location-and-annotation-data","dir":"Articles","previous_headings":"Test dataset","what":"2 Genomic location and annotation data","title":"HicAggR - In depth tutorial","text":"kind data can imported R rtracklayer package.","code":""},{"path":"/articles/InDepth.html","id":"chipseq-peaks-of-beaf-32-protein","dir":"Articles","previous_headings":"Test dataset > 2 Genomic location and annotation data","what":"ChIPseq peaks of Beaf-32 protein","title":"HicAggR - In depth tutorial","text":"","code":"data(\"Beaf32_Peaks.gnr\")"},{"path":"/articles/InDepth.html","id":"tss-annontation","dir":"Articles","previous_headings":"Test dataset > 2 Genomic location and annotation data","what":"TSS annontation","title":"HicAggR - In depth tutorial","text":"","code":"data(\"TSS_Peaks.gnr\")"},{"path":"/articles/InDepth.html","id":"tads-annotation","dir":"Articles","previous_headings":"Test dataset > 2 Genomic location and annotation data","what":"TADs annotation","title":"HicAggR - In depth tutorial","text":"","code":"data(\"TADs_Domains.gnr\")"},{"path":"/articles/InDepth.html","id":"additional-genome-informations","dir":"Articles","previous_headings":"Test dataset","what":"Additional genome informations","title":"HicAggR - In depth tutorial","text":"Required genomic informations used functions entire pipeline data.frame containing chromosomes names sized binSize, corresponding HiC matrices resolution.","code":"seqlengths.num <- c('2L'=23513712, '2R'=25286936) chromSizes  <- data.frame(     seqnames   = names(seqlengths.num ),      seqlengths = seqlengths.num     ) binSize <- 1000"},{"path":"/articles/InDepth.html","id":"import-hic","dir":"Articles","previous_headings":"","what":"Import HiC","title":"HicAggR - In depth tutorial","text":"package supports import normalization HiC data. NOTE: Since version 0.99.2, package supports import balanced HiC matrices .hic, .cool/.mcool formats. also supports import ‘o/e’ matrices .hic format.","code":""},{"path":"/articles/InDepth.html","id":"import","dir":"Articles","previous_headings":"Import HiC","what":"Import","title":"HicAggR - In depth tutorial","text":"HicAggR can import HiC data stored main formats: .hic, .cool, .mcool, .h5 (since version 0.99.2). pacakage imports default raw counts. Therefore, necessary perform balancing observed/expected correction steps.","code":"HiC_Ctrl.cmx_lst <- ImportHiC(         file    = HicOutput.pth,         hicResolution     = 1000,         chrom_1 = c(\"2L\", \"2L\", \"2R\"),         chrom_2 = c(\"2L\", \"2R\", \"2R\") ) HiC_HS.cmx_lst <- ImportHiC(         file    = McoolOutput.pth,         hicResolution     = 1000,         chrom_1 = c(\"2L\", \"2L\", \"2R\"),         chrom_2 = c(\"2L\", \"2R\", \"2R\") )"},{"path":"/articles/InDepth.html","id":"balancing","dir":"Articles","previous_headings":"Import HiC","what":"Balancing","title":"HicAggR - In depth tutorial","text":"balancing done every bin matrix approximately number contacts within contactMatrix.","code":"HiC_Ctrl.cmx_lst <- BalanceHiC(HiC_Ctrl.cmx_lst) HiC_HS.cmx_lst <- BalanceHiC(HiC_HS.cmx_lst)"},{"path":"/articles/InDepth.html","id":"tips","dir":"Articles","previous_headings":"Import HiC > Balancing","what":"Tips","title":"HicAggR - In depth tutorial","text":"interactionType parameter required define “cis” “trans”. function return ContactMatrices corresponding category (“cis” “trans”). categories removed result. interactionType parameter type c(“cis”,“trans”) function normalize separetly “cis” “trans”. type “” function normalize “cis” “trans” matrices together.","code":""},{"path":"/articles/InDepth.html","id":"observedexpected-correction","dir":"Articles","previous_headings":"Import HiC","what":"Observed/Expected Correction","title":"HicAggR - In depth tutorial","text":"correct effects due genomic distance matrix corrected expected values genomic distance. expected values default calculated average values contacts per chromosome per distance. NOTE: Since version 0.99.3, 2 options calculate expected values implemented. designated methods “lieberman” “mean_total”. methods implemented based options proposed HiCExplorer’s hicTransform program. “lieberman” method computes per distance (d) expected values dividing sum contacts difference chromosome length distance(d). “mean_total” simply average contact values including 0 values, ignored default method (“mean_non_zero”)","code":"HiC_Ctrl.cmx_lst <- OverExpectedHiC(HiC_Ctrl.cmx_lst) HiC_HS.cmx_lst <- OverExpectedHiC(HiC_HS.cmx_lst)"},{"path":"/articles/InDepth.html","id":"tips-1","dir":"Articles","previous_headings":"Import HiC > Observed/Expected Correction","what":"Tips","title":"HicAggR - In depth tutorial","text":"runing OverExpectedHiC function, expected counts can plotted function genomic distances tibble taking expected attributes.","code":""},{"path":"/articles/InDepth.html","id":"hic-data-format-contactmatrix-list-structure","dir":"Articles","previous_headings":"Import HiC","what":"HiC data format: ContactMatrix list structure","title":"HicAggR - In depth tutorial","text":"element list corresponds ContactMatrix object (dgCMatrix object, sparse matrix format) storing contact frequencies one chromosome (cis-interactions, ex: “2L_2L”) two chromosomes (trans-interactions, ex: “2L_2R”). HiC data format based InteractionSet Matrix packages. list attributes described . attributes accessible via: names : names list elements (ContactMatrix). resolution : resolution HiC map. chromSize : size chromosomes tibble format. - seqnames : sequence name (chromosome name). - seqlengths : sequence length base pairs. - dimension : sequence length number bins. matricesKind : kind matrix composes list tibble format. - name : matrix name. - type : interactionType. “Cis” interactions chromosome “Trans” interactions different chromosomes. - kind : matrix kind. U upper triangle matrices, L lower triangle matrices, NA rectangular square matrices. - symmetric : boolean indicates whether matrix symmetric (lower triangle identical upper triangle). mtx : kind values matrix. exemple observed counts, normalized counts, observed/expected, etc. expected : attribute related OverExpectedHiC function. gives tibble expected counts function genomic distance. contactmatrix list metadata. accessible via: name : name ContactMatrix. type : interactionType. “Cis” interactions chromosome “Trans” interactions different chromosomes (arms). kind : matrix kind. U upper triangle matrices, L lower triangle matrices, NA rectangular square symmetric : boolean indicates whether matrix symmetric (lower triangle identical upper triangle). resolution : resolution HiC map. removedCounts : sparse matrix (dgCMatrix) removed counts (counts threshold rows columns described BalanceHiC). observed : observed counts sparse matrix. normalizer : balancer vector converts observed counts normalized counts. (observed * normalizer = normalized counts). mtx : kind values matrix. example observed counts, normalized counts, observed/expected, etc. expected : attributes related OverExpectedHiC function. gives expected vector convert normalized counts observed/expected counts (normalized counts / expected = observed/expected).","code":"str(HiC_Ctrl.cmx_lst,max.level = 4) #> List of 3 #>  $ 2L_2L:Formal class 'ContactMatrix' [package \"InteractionSet\"] with 5 slots #>   .. ..@ matrix  :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ anchor1 : int [1:23514] 1 2 3 4 5 6 7 8 9 10 ... #>   .. ..@ anchor2 : int [1:23514] 1 2 3 4 5 6 7 8 9 10 ... #>   .. ..@ regions :Formal class 'GRanges' [package \"GenomicRanges\"] with 7 slots #>   .. ..@ metadata:List of 10 #>   .. .. ..$ name         : chr \"2L_2L\" #>   .. .. ..$ type         : chr \"cis\" #>   .. .. ..$ kind         : chr \"U\" #>   .. .. ..$ symmetric    : logi TRUE #>   .. .. ..$ resolution   : num 1000 #>   .. .. ..$ expected     : num [1:6540004] 52 65.8 52 39.8 65.8 ... #>   .. .. ..$ removedCounts:Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. .. ..$ observed     : num [1:6540004] 41 126 34 60 90 32 77 89 74 87 ... #>   .. .. ..$ normalizer   : num [1:6540004] 1.085 0.971 0.869 1.345 1.203 ... #>   .. .. ..$ mtx          : chr \"norm\" #>  $ 2L_2R:Formal class 'ContactMatrix' [package \"InteractionSet\"] with 5 slots #>   .. ..@ matrix  :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ anchor1 : int [1:23514] 1 2 3 4 5 6 7 8 9 10 ... #>   .. ..@ anchor2 : int [1:25287] 23515 23516 23517 23518 23519 23520 23521 23522 23523 23524 ... #>   .. ..@ regions :Formal class 'GRanges' [package \"GenomicRanges\"] with 7 slots #>   .. ..@ metadata:List of 9 #>   .. .. ..$ name         : chr \"2L_2R\" #>   .. .. ..$ type         : chr \"trans\" #>   .. .. ..$ kind         : chr NA #>   .. .. ..$ symmetric    : logi FALSE #>   .. .. ..$ resolution   : num 1000 #>   .. .. ..$ removedCounts:Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. .. ..$ observed     : num [1:1459521] 1 1 1 1 1 1 1 1 1 1 ... #>   .. .. ..$ normalizer   : num [1:1459521] 5.4 11.23 4.2 7.18 3.08 ... #>   .. .. ..$ expected     : num 0.00248 #>  $ 2R_2R:Formal class 'ContactMatrix' [package \"InteractionSet\"] with 5 slots #>   .. ..@ matrix  :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ anchor1 : int [1:25287] 1 2 3 4 5 6 7 8 9 10 ... #>   .. ..@ anchor2 : int [1:25287] 1 2 3 4 5 6 7 8 9 10 ... #>   .. ..@ regions :Formal class 'GRanges' [package \"GenomicRanges\"] with 7 slots #>   .. ..@ metadata:List of 10 #>   .. .. ..$ name         : chr \"2R_2R\" #>   .. .. ..$ type         : chr \"cis\" #>   .. .. ..$ kind         : chr \"U\" #>   .. .. ..$ symmetric    : logi TRUE #>   .. .. ..$ resolution   : num 1000 #>   .. .. ..$ expected     : num [1:7019675] 37.7 52.5 45.6 52.5 25 ... #>   .. .. ..$ removedCounts:Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. .. ..$ observed     : num [1:7019675] 2 11 2 1 6 7 7 19 1 1 ... #>   .. .. ..$ normalizer   : num [1:7019675] 16.14 7.53 26.57 93.73 8.38 ... #>   .. .. ..$ mtx          : chr \"norm\" #>  - attr(*, \"resolution\")= num 1000 #>  - attr(*, \"chromSize\")= tibble [2 × 3] (S3: tbl_df/tbl/data.frame) #>   ..$ name     : chr [1:2] \"2L\" \"2R\" #>   ..$ length   : num [1:2] 23513712 25286936 #>   ..$ dimension: num [1:2] 23514 25287 #>  - attr(*, \"matricesKind\")= tibble [3 × 4] (S3: tbl_df/tbl/data.frame) #>   ..$ name     : chr [1:3] \"2L_2L\" \"2L_2R\" \"2R_2R\" #>   ..$ type     : chr [1:3] \"cis\" \"trans\" \"cis\" #>   ..$ kind     : chr [1:3] \"U\" NA \"U\" #>   ..$ symmetric: logi [1:3] TRUE FALSE TRUE #>  - attr(*, \"mtx\")= chr \"o/e\" #>  - attr(*, \"expected\")= tibble [24,362 × 2] (S3: tbl_df/tbl/data.frame) #>   ..$ distance: num [1:24362] 1 1001 2001 3001 4001 ... #>   ..$ expected: num [1:24362] 52.3 68.7 42.8 35.5 30.4 ... #> attributes(HiC_Ctrl.cmx_lst) #> $names #> [1] \"2L_2L\" \"2L_2R\" \"2R_2R\" #>  #> $resolution #> [1] 1000 #>  #> $chromSize #> # A tibble: 2 × 3 #>   name    length dimension #>   <chr>    <dbl>     <dbl> #> 1 2L    23513712     23514 #> 2 2R    25286936     25287 #>  #> $matricesKind #> # A tibble: 3 × 4 #>   name  type  kind  symmetric #>   <chr> <chr> <chr> <lgl>     #> 1 2L_2L cis   U     TRUE      #> 2 2L_2R trans NA    FALSE     #> 3 2R_2R cis   U     TRUE      #>  #> $mtx #> [1] \"o/e\" #>  #> $expected #> # A tibble: 24,362 × 2 #>   distance expected #>      <dbl>    <dbl> #> 1        1     52.3 #> 2     1001     68.7 #> 3     2001     42.8 #> 4     3001     35.5 #> # ℹ 24,358 more rows #> str(S4Vectors::metadata(HiC_Ctrl.cmx_lst[[\"2L_2L\"]])) #> List of 10 #>  $ name         : chr \"2L_2L\" #>  $ type         : chr \"cis\" #>  $ kind         : chr \"U\" #>  $ symmetric    : logi TRUE #>  $ resolution   : num 1000 #>  $ expected     : num [1:6540004] 52 65.8 52 39.8 65.8 ... #>  $ removedCounts:Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ i       : int [1:67995] 5 7 8 9 11 11 11 11 17 28 ... #>   .. ..@ p       : int [1:23515] 0 0 0 0 0 0 0 0 0 0 ... #>   .. ..@ Dim     : int [1:2] 23514 23514 #>   .. ..@ Dimnames:List of 2 #>   .. .. ..$ : NULL #>   .. .. ..$ : NULL #>   .. ..@ x       : num [1:67995] 1 2 3 1 2 3 3 1 1 1 ... #>   .. ..@ factors : list() #>  $ observed     : num [1:6540004] 41 126 34 60 90 32 77 89 74 87 ... #>  $ normalizer   : num [1:6540004] 1.085 0.971 0.869 1.345 1.203 ... #>  $ mtx          : chr \"norm\" #>"},{"path":"/articles/InDepth.html","id":"indexing","dir":"Articles","previous_headings":"","what":"Indexing","title":"HicAggR - In depth tutorial","text":"part data corresponds positioning data (ChIPseq peaks, genomic features annotations, genes, etc) genome. integrate annotations HiC data 2D matrices, annotations must processed followed. first step indexing features. allows features splitted grouped bins corresponding HiC bin size.","code":""},{"path":"/articles/InDepth.html","id":"example-1-anchors-from-beaf32-chip-seq-peaks-bed-file","dir":"Articles","previous_headings":"Indexing","what":"Example 1: Anchors from Beaf32 ChIP-seq peaks (bed file)","title":"HicAggR - In depth tutorial","text":"","code":"anchors_Index.gnr <- IndexFeatures(     gRangeList        = list(Beaf=Beaf32_Peaks.gnr),      genomicConstraint        = TADs_Domains.gnr,     chromSizes         = chromSizes,     binSize           = binSize,     metadataColName = \"score\",     method            = \"max\"     )"},{"path":"/articles/InDepth.html","id":"example-2-baits-from-tss-transcription-start-sites-from-ucsc","dir":"Articles","previous_headings":"Indexing","what":"Example 2: Baits from TSS (transcription start sites from UCSC)","title":"HicAggR - In depth tutorial","text":"","code":"baits_Index.gnr <- IndexFeatures(     gRangeList        = list(Tss=TSS_Peaks.gnr),     genomicConstraint        = TADs_Domains.gnr,     chromSizes         = chromSizes,     binSize           = binSize,     metadataColName = \"score\",     method            = \"max\"     )"},{"path":"/articles/InDepth.html","id":"filter-indexed-features","dir":"Articles","previous_headings":"Indexing","what":"Filter indexed features:","title":"HicAggR - In depth tutorial","text":"using features names bin IDs, possible filter subset features. Example: Subset TSS bin Beaf32 peak.","code":"non_Overlaps.ndx <- match(baits_Index.gnr$bin,      anchors_Index.gnr$bin, nomatch=0L)==0L baits_Index.gnr <- baits_Index.gnr[non_Overlaps.ndx,]"},{"path":"/articles/InDepth.html","id":"tips-2","dir":"Articles","previous_headings":"Indexing","what":"Tips","title":"HicAggR - In depth tutorial","text":"possible index multiple features time submitting named list GRanges. Names given list GRanges can used filter indexed features pairs. genomicConstraint defined, anchors baits paired located within region . contraint.gnr NULL, entire chromosomes (arms) used constraints. multiple ranges bin (ex: 3 ChIP-seq peaks 10kb bin), associated numeric variables metadata (metadataColName) can summarized according defined method (method), Example: Max peak score bin kept metadata column score.","code":""},{"path":[]},{"path":"/articles/InDepth.html","id":"pairing","dir":"Articles","previous_headings":"Search Pairs","what":"Pairing","title":"HicAggR - In depth tutorial","text":"SearchPairs function takes input one two indexed features returns putative pairs within constraint (ex: wihtin TAD). one indexed features defined indexAnchor, SearchPairs return symetrical homotypic pairs (<->), indexAnchor indexBait defined, return asymetrical heterotypic pairs (<->B).","code":"interactions.gni <- SearchPairs(         indexAnchor = anchors_Index.gnr,         indexBait   = baits_Index.gnr         )"},{"path":"/articles/InDepth.html","id":"tips-3","dir":"Articles","previous_headings":"Search Pairs","what":"Tips","title":"HicAggR - In depth tutorial","text":"indexBait NULL, SearchPairs return homotypic pairs indexAnchor. Minimum maximum distances pairs anchors can set. Note also possible filter pairs within specific distance later .","code":""},{"path":[]},{"path":[]},{"path":"/articles/InDepth.html","id":"interactions-defined-with-ginteraction-or-pairs-of-granges-","dir":"Articles","previous_headings":"Extractions > Case 1: Long-range interactions between two distal anchors.","what":"Interactions defined with GInteraction or Pairs of GRanges.","title":"HicAggR - In depth tutorial","text":"extracted matrices, middle Y axis corresponds center first element interacts center second element middle X axis.","code":"interactions_PFmatrix.lst <- ExtractSubmatrix(     genomicFeature         = interactions.gni,     hicLst        = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\",     matriceDim     = 41     )"},{"path":"/articles/InDepth.html","id":"interactions-defined-with-granges-","dir":"Articles","previous_headings":"Extractions > Case 1: Long-range interactions between two distal anchors.","what":"Interactions defined with GRanges.","title":"HicAggR - In depth tutorial","text":"middle Y axis corresponds start range interacts middle X axis corresponds end range.","code":"domains_PFmatrix.lst <- ExtractSubmatrix(     genomicFeature         = TADs_Domains.gnr,     hicLst        = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\",     matriceDim     = 41     )"},{"path":"/articles/InDepth.html","id":"case-2-interactions-around-genomic-regions-or-domains-","dir":"Articles","previous_headings":"Extractions","what":"Case 2: Interactions around genomic regions or domains.","title":"HicAggR - In depth tutorial","text":"case, extracted matrices resized scaled order fit regions area.","code":""},{"path":"/articles/InDepth.html","id":"regions-defined-with-ginteraction-object-or-pairs-of-granges","dir":"Articles","previous_headings":"Extractions > Case 2: Interactions around genomic regions or domains.","what":"Regions defined with GInteraction object or Pairs of GRanges","title":"HicAggR - In depth tutorial","text":"region’s start defined center first element region’s end center second element.","code":"interactions_RFmatrix_ctrl.lst  <- ExtractSubmatrix(     genomicFeature         = interactions.gni,     hicLst        = HiC_Ctrl.cmx_lst,     hicResolution            = NULL,     referencePoint = \"rf\",     matriceDim     = 101     )"},{"path":"/articles/InDepth.html","id":"regions-defined-with-granges","dir":"Articles","previous_headings":"Extractions > Case 2: Interactions around genomic regions or domains.","what":"Regions defined with GRanges","title":"HicAggR - In depth tutorial","text":"regions directly defined ranges GRanges object.","code":"domains_RFmatrix.lst <- ExtractSubmatrix(     genomicFeature         = TADs_Domains.gnr,     hicLst        = HiC_Ctrl.cmx_lst,     referencePoint = \"rf\",     matriceDim     = 101,     cores          = 1,     verbose        = FALSE     )"},{"path":[]},{"path":"/articles/InDepth.html","id":"example-to-analyse-interactions-in-the-context-of-tads","dir":"Articles","previous_headings":"Extractions > Case 3: Interactions along the chromosome axis.","what":"Example to analyse interactions in the context of TADs:","title":"HicAggR - In depth tutorial","text":"Step 1: generate GRanges object TAD boundaries concatenating starts ends TADs. Step 2: Filter reduce TAD boundaries GRanges object according HiC resolution (binSize) + Store TAD names. Step 3: defines GRanges object. folowing examples, information needed GInteraction object class.","code":"domains_Border.gnr <- c(         GenomicRanges::resize(TADs_Domains.gnr, 1, \"start\"),         GenomicRanges::resize(TADs_Domains.gnr, 1,  \"end\" ) ) |> sort() domains_Border_Bin.gnr <- BinGRanges(     gRange  = domains_Border.gnr,     binSize = binSize,     verbose = FALSE     ) domains_Border_Bin.gnr$subname <- domains_Border_Bin.gnr$name domains_Border_Bin.gnr$name    <- domains_Border_Bin.gnr$bin domains_Border_Bin.gnr domains_Border_Bin.gni <-      InteractionSet::GInteractions(         domains_Border_Bin.gnr,domains_Border_Bin.gnr)"},{"path":"/articles/InDepth.html","id":"ponctual-interactions-defined-with-granges","dir":"Articles","previous_headings":"Extractions > Case 3: Interactions along the chromosome axis.","what":"Ponctual interactions defined with GRanges","title":"HicAggR - In depth tutorial","text":"start end ranges bin.","code":"border_PFmatrix.lst <- ExtractSubmatrix(     genomicFeature         = domains_Border_Bin.gnr,     hicLst        = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\",     matriceDim     = 101 )"},{"path":"/articles/InDepth.html","id":"ponctual-interactions-defined-with-ginteractions","dir":"Articles","previous_headings":"Extractions > Case 3: Interactions along the chromosome axis.","what":"Ponctual interactions defined with GInteractions","title":"HicAggR - In depth tutorial","text":"first (blue scheme) second (red scheme) elements .","code":"border_PFmatrix.lst <- ExtractSubmatrix(     genomicFeature         = domains_Border_Bin.gni,     hicLst        = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\",     matriceDim     = 101 )"},{"path":"/articles/InDepth.html","id":"tips-4","dir":"Articles","previous_headings":"Extractions","what":"Tips","title":"HicAggR - In depth tutorial","text":"hicResolution NULL, function atuomatically use resolution hicLst attributes. referencePoint automatically set “pf” every anchors baits bin (see examples).","code":""},{"path":"/articles/InDepth.html","id":"filtrations","dir":"Articles","previous_headings":"","what":"Filtrations","title":"HicAggR - In depth tutorial","text":"modularity workflow allows user filter interactions, pairs extracted submatrices step analysis. FilterInteractions function takes input either GInteraction object list submatrices, list targets choice selectionFunction defining targets filtered.","code":""},{"path":"/articles/InDepth.html","id":"target-list-definition","dir":"Articles","previous_headings":"Filtrations","what":"Target list definition:","title":"HicAggR - In depth tutorial","text":"Target list must defined named list corresponding names element correspond column GInteraction (attributes “interactions” matrices filtered). element must character list match column function test row column return bolean. Interactions, pairs extracted submatrices filtered metadata elements GRanges objects used SearchPairs. metadata stored attributes list submatrices accessible follow:","code":"structureTarget.lst <- list(     first_colname_of_GInteraction  = c(\"value\"),     second_colname_of_GInteraction = function(eachElement){         min_th<value && value<max_th}     ) attributes(interactions_RFmatrix_ctrl.lst)$interactions names(S4Vectors::mcols(attributes(interactions_RFmatrix_ctrl.lst)$interactions))"},{"path":"/articles/InDepth.html","id":"example-of-target-list","dir":"Articles","previous_headings":"Filtrations > Target list definition:","what":"Example of target list:","title":"HicAggR - In depth tutorial","text":"example, Pairs filtered anchor.Beaf.name, bait.Tss.name, name (correponds submatrix IDs) distance. aim example filter Pairs submatrices : “Beaf32_8” “Beaf32_15” anchor.Beaf.name “FBgn0031214” “FBgn0005278” bait.Tss.name distance exactly equal 14000 3000 exclude Pairs submatrices : “2L:74_2L:77” name","code":"targets <- list(     anchor.Beaf.name = c(\"Beaf32_8\",\"Beaf32_15\"),     bait.Tss.name    = c(\"FBgn0031214\",\"FBgn0005278\"),     name             = c(\"2L:74_2L:77\"),     distance         = function(columnElement){         return(14000==columnElement || columnElement == 3000)         }     )"},{"path":"/articles/InDepth.html","id":"selection-function-definition","dir":"Articles","previous_headings":"Filtrations","what":"Selection Function definition:","title":"HicAggR - In depth tutorial","text":"selectionFunction defines operations (union(), intersect(), setdiff()…) used filter set Pairs target elements. examples, see Selection function tips examples section.","code":""},{"path":"/articles/InDepth.html","id":"example-of-selectionfunction-according-to-the-example-target","dir":"Articles","previous_headings":"Filtrations > Selection Function definition:","what":"Example of selectionFunction according to the example target","title":"HicAggR - In depth tutorial","text":"Following example case defined targets","code":"selectionFun = function(){     Reduce(intersect, list(anchor.Beaf.name, bait.Tss.name ,distance) ) |>     setdiff(name)     }"},{"path":[]},{"path":"/articles/InDepth.html","id":"example-of-ginteraction-object-filtration","dir":"Articles","previous_headings":"Filtrations > Filtration with selection","what":"Example of GInteraction object filtration","title":"HicAggR - In depth tutorial","text":"GInteraction object input, FilterInteractions return indices filtered elements. targets selectionFun defined :","code":"FilterInteractions(     genomicInteractions =          attributes(interactions_RFmatrix_ctrl.lst)$interactions,     targets        = targets,     selectionFun     = selectionFun     ) #> [1] 3"},{"path":"/articles/InDepth.html","id":"example-of-matrices-list-filtration","dir":"Articles","previous_headings":"Filtrations > Filtration with selection","what":"Example of Matrices list filtration","title":"HicAggR - In depth tutorial","text":"matrices list input, FilterInteractions return filtered matrices list, updated attributes. targets selectionFun defined :","code":"filtred_interactions_RFmatrix_ctrl.lst <- FilterInteractions(     matrices  = interactions_RFmatrix_ctrl.lst,     targets    = targets,     selectionFun = selectionFun     )"},{"path":"/articles/InDepth.html","id":"specific-case-1-only-one-target-and-therefore-no-selection-needed","dir":"Articles","previous_headings":"Filtrations","what":"Specific case 1: Only one target (and therefore no selection needed)","title":"HicAggR - In depth tutorial","text":"example, filter top 100 first elements, select top 100 first names","code":"first100_targets = list(     submatrix.name = names(interactions_RFmatrix_ctrl.lst)[1:100]     )"},{"path":"/articles/InDepth.html","id":"ginteraction-filtration","dir":"Articles","previous_headings":"Filtrations > Specific case 1: Only one target (and therefore no selection needed)","what":"GInteraction filtration","title":"HicAggR - In depth tutorial","text":"","code":"FilterInteractions(     genomicInteractions =          attributes(interactions_RFmatrix_ctrl.lst)$interactions,     targets        = first100_targets,     selectionFun     = NULL     ) |> head() #> submatrix.name1 submatrix.name2 submatrix.name3 submatrix.name4 submatrix.name5  #>               1               2               3               4               5  #> submatrix.name6  #>               6"},{"path":"/articles/InDepth.html","id":"matrices-list-filtration","dir":"Articles","previous_headings":"Filtrations > Specific case 1: Only one target (and therefore no selection needed)","what":"Matrices list filtration","title":"HicAggR - In depth tutorial","text":"Warning! selection matrices removes attributes.","code":"first100_interactions_RFmatrix_ctrl.lst <- FilterInteractions(     matrices  = interactions_RFmatrix_ctrl.lst,     targets    = first100_targets,     selectionFun = NULL     ) attributes(first100_interactions_RFmatrix_ctrl.lst)$interactions #> GInteractions object with 100 interactions and 15 metadata columns: #>                     seqnames1           ranges1     seqnames2           ranges2 #>                         <Rle>         <IRanges>         <Rle>         <IRanges> #>         2L:74_2L:77        2L       73001-74000 ---        2L       76001-77000 #>       2L:115_2L:107        2L     114001-115000 ---        2L     106001-107000 #>       2L:121_2L:107        2L     120001-121000 ---        2L     106001-107000 #>       2L:121_2L:117        2L     120001-121000 ---        2L     116001-117000 #>       2L:274_2L:268        2L     273001-274000 ---        2L     267001-268000 #>                 ...       ...               ... ...       ...               ... #>   2L:12515_2L:12498        2L 12514001-12515000 ---        2L 12497001-12498000 #>   2L:12516_2L:12498        2L 12515001-12516000 ---        2L 12497001-12498000 #>   2L:12515_2L:12508        2L 12514001-12515000 ---        2L 12507001-12508000 #>   2L:12516_2L:12508        2L 12515001-12516000 ---        2L 12507001-12508000 #>   2L:12515_2L:12509        2L 12514001-12515000 ---        2L 12508001-12509000 #>                     |              name  constraint  distance orientation #>                     |       <character> <character> <integer>   <logical> #>         2L:74_2L:77 |       2L:74_2L:77       Tad_1      3000        TRUE #>       2L:115_2L:107 |     2L:115_2L:107       Tad_3      8000       FALSE #>       2L:121_2L:107 |     2L:121_2L:107       Tad_3     14000       FALSE #>       2L:121_2L:117 |     2L:121_2L:117       Tad_3      4000       FALSE #>       2L:274_2L:268 |     2L:274_2L:268      Tad_10      6000       FALSE #>                 ... .               ...         ...       ...         ... #>   2L:12515_2L:12498 | 2L:12515_2L:12498     Tad_310     17000       FALSE #>   2L:12516_2L:12498 | 2L:12516_2L:12498     Tad_310     18000       FALSE #>   2L:12515_2L:12508 | 2L:12515_2L:12508     Tad_310      7000       FALSE #>   2L:12516_2L:12508 | 2L:12516_2L:12508     Tad_310      8000       FALSE #>   2L:12515_2L:12509 | 2L:12515_2L:12509     Tad_310      6000       FALSE #>                        submatrix.name  anchor.bin      anchor.name    bait.bin #>                           <character> <character>      <character> <character> #>         2L:74_2L:77       2L:74_2L:77       2L:74      2L:74:Tad_1       2L:77 #>       2L:115_2L:107     2L:107_2L:115      2L:115     2L:115:Tad_3      2L:107 #>       2L:121_2L:107     2L:107_2L:121      2L:121     2L:121:Tad_3      2L:107 #>       2L:121_2L:117     2L:117_2L:121      2L:121     2L:121:Tad_3      2L:117 #>       2L:274_2L:268     2L:268_2L:274      2L:274    2L:274:Tad_10      2L:268 #>                 ...               ...         ...              ...         ... #>   2L:12515_2L:12498 2L:12498_2L:12515    2L:12515 2L:12515:Tad_310    2L:12498 #>   2L:12516_2L:12498 2L:12498_2L:12516    2L:12516 2L:12516:Tad_310    2L:12498 #>   2L:12515_2L:12508 2L:12508_2L:12515    2L:12515 2L:12515:Tad_310    2L:12508 #>   2L:12516_2L:12508 2L:12508_2L:12516    2L:12516 2L:12516:Tad_310    2L:12508 #>   2L:12515_2L:12509 2L:12509_2L:12515    2L:12515 2L:12515:Tad_310    2L:12509 #>                            bait.name anchor.Beaf.score anchor.Beaf.name #>                          <character>         <numeric>           <list> #>         2L:74_2L:77      2L:77:Tad_1               205         Beaf32_8 #>       2L:115_2L:107     2L:107:Tad_3              1707        Beaf32_14 #>       2L:121_2L:107     2L:107:Tad_3               484        Beaf32_15 #>       2L:121_2L:117     2L:117:Tad_3               484        Beaf32_15 #>       2L:274_2L:268    2L:268:Tad_10               210        Beaf32_39 #>                 ...              ...               ...              ... #>   2L:12515_2L:12498 2L:12498:Tad_310                44       Beaf32_900 #>   2L:12516_2L:12498 2L:12498:Tad_310                88       Beaf32_901 #>   2L:12515_2L:12508 2L:12508:Tad_310                44       Beaf32_900 #>   2L:12516_2L:12508 2L:12508:Tad_310                88       Beaf32_901 #>   2L:12515_2L:12509 2L:12509:Tad_310                44       Beaf32_900 #>                     anchor.Beaf.bln bait.Tss.class           bait.Tss.name #>                           <logical>         <list>                  <list> #>         2L:74_2L:77            TRUE       inactive             FBgn0031214 #>       2L:115_2L:107            TRUE         active FBgn0026787,FBgn0005278 #>       2L:121_2L:107            TRUE         active FBgn0026787,FBgn0005278 #>       2L:121_2L:117            TRUE         active             FBgn0031219 #>       2L:274_2L:268            TRUE       inactive             FBgn0031239 #>                 ...             ...            ...                     ... #>   2L:12515_2L:12498            TRUE       inactive             FBgn0051858 #>   2L:12516_2L:12498            TRUE       inactive             FBgn0051858 #>   2L:12515_2L:12508            TRUE       inactive             FBgn0262353 #>   2L:12516_2L:12508            TRUE       inactive             FBgn0262353 #>   2L:12515_2L:12509            TRUE       inactive             FBgn0263458 #>                     bait.Tss.bln #>                        <logical> #>         2L:74_2L:77         TRUE #>       2L:115_2L:107         TRUE #>       2L:121_2L:107         TRUE #>       2L:121_2L:117         TRUE #>       2L:274_2L:268         TRUE #>                 ...          ... #>   2L:12515_2L:12498         TRUE #>   2L:12516_2L:12498         TRUE #>   2L:12515_2L:12508         TRUE #>   2L:12516_2L:12508         TRUE #>   2L:12515_2L:12509         TRUE #>   ------- #>   regions: 429 ranges and 0 metadata columns #>   seqinfo: 2 sequences from an unspecified genome attributes(interactions_RFmatrix_ctrl.lst[1:20])$interactions #> NULL"},{"path":"/articles/InDepth.html","id":"specific-case-2-sampling","dir":"Articles","previous_headings":"Filtrations","what":"Specific case 2: Sampling","title":"HicAggR - In depth tutorial","text":"","code":"nSample.num = 3 set.seed(123) targets = list(name=sample(     attributes(interactions_RFmatrix_ctrl.lst)$interactions$name,nSample.num))"},{"path":"/articles/InDepth.html","id":"ginteraction-sampling","dir":"Articles","previous_headings":"Filtrations > Specific case 2: Sampling","what":"GInteraction sampling","title":"HicAggR - In depth tutorial","text":"","code":"FilterInteractions(     genomicInteractions =          attributes(interactions_RFmatrix_ctrl.lst)$interactions,     targets        = targets,     selectionFun     = NULL     ) #> name1 name2 name3  #>    14   179   195"},{"path":"/articles/InDepth.html","id":"matrices-list-sampling","dir":"Articles","previous_headings":"Filtrations > Specific case 2: Sampling","what":"Matrices list sampling","title":"HicAggR - In depth tutorial","text":"","code":"sampled_interactions_RFmatrix_ctrl.lst <- FilterInteractions(     matrices  = interactions_RFmatrix_ctrl.lst,     targets    = targets,     selectionFun = NULL     ) attributes(sampled_interactions_RFmatrix_ctrl.lst)$interactions #> GInteractions object with 3 interactions and 15 metadata columns: #>                     seqnames1           ranges1     seqnames2           ranges2 #>                         <Rle>         <IRanges>         <Rle>         <IRanges> #>     2L:1178_2L:1174        2L   1177001-1178000 ---        2L   1173001-1174000 #>   2L:21574_2L:21492        2L 21573001-21574000 ---        2L 21491001-21492000 #>     2R:5672_2R:5653        2R   5671001-5672000 ---        2R   5652001-5653000 #>                     |              name  constraint  distance orientation #>                     |       <character> <character> <integer>   <logical> #>     2L:1178_2L:1174 |   2L:1178_2L:1174      Tad_35      4000       FALSE #>   2L:21574_2L:21492 | 2L:21574_2L:21492     Tad_486     82000       FALSE #>     2R:5672_2R:5653 |   2R:5672_2R:5653     Tad_513     19000       FALSE #>                        submatrix.name  anchor.bin      anchor.name    bait.bin #>                           <character> <character>      <character> <character> #>     2L:1178_2L:1174   2L:1174_2L:1178     2L:1178   2L:1178:Tad_35     2L:1174 #>   2L:21574_2L:21492 2L:21492_2L:21574    2L:21574 2L:21574:Tad_486    2L:21492 #>     2R:5672_2R:5653   2R:5653_2R:5672     2R:5672  2R:5672:Tad_513     2R:5653 #>                            bait.name anchor.Beaf.score anchor.Beaf.name #>                          <character>         <numeric>           <list> #>     2L:1178_2L:1174   2L:1174:Tad_35               921       Beaf32_130 #>   2L:21574_2L:21492 2L:21492:Tad_486               529      Beaf32_1349 #>     2R:5672_2R:5653  2R:5653:Tad_513                99      Beaf32_1462 #>                     anchor.Beaf.bln bait.Tss.class bait.Tss.name bait.Tss.bln #>                           <logical>         <list>        <list>    <logical> #>     2L:1178_2L:1174            TRUE         active   FBgn0031318         TRUE #>   2L:21574_2L:21492            TRUE       inactive   FBgn0053837         TRUE #>     2R:5672_2R:5653            TRUE         active   FBgn0033028         TRUE #>   ------- #>   regions: 429 ranges and 0 metadata columns #>   seqinfo: 2 sequences from an unspecified genome"},{"path":"/articles/InDepth.html","id":"specific-case-3-filtration-without-selectionfunction","dir":"Articles","previous_headings":"Filtrations","what":"Specific case 3: Filtration without selectionFunction","title":"HicAggR - In depth tutorial","text":"Without selectionFunction, FilterInteractions return indices corresponding target list. , indices interest can selected second step. examples take folowing targets:","code":"targets <- list(     anchor.Beaf.name = c(\"Beaf32_8\",\"Beaf32_15\"),     bait.Tss.name    = c(\"FBgn0031214\",\"FBgn0005278\"),     name             = c(\"2L:74_2L:77\"),     distance         = function(columnElement){         return(14000==columnElement || columnElement == 3000)         }     )"},{"path":"/articles/InDepth.html","id":"ginteraction-filtration-1","dir":"Articles","previous_headings":"Filtrations > Specific case 3: Filtration without selectionFunction","what":"GInteraction filtration","title":"HicAggR - In depth tutorial","text":"","code":"FilterInteractions(     genomicInteractions =          attributes(interactions_RFmatrix_ctrl.lst)$interactions,     targets        = targets,     selectionFun     = NULL     ) |> str() #> List of 4 #>  $ anchor.Beaf.name: int [1:3] 1 3 4 #>  $ bait.Tss.name   : int [1:3] 1 2 3 #>  $ name            : int 1 #>  $ distance        : int [1:25] 1 3 8 24 38 49 63 65 80 102 ..."},{"path":"/articles/InDepth.html","id":"matrices-list-filtration-1","dir":"Articles","previous_headings":"Filtrations > Specific case 3: Filtration without selectionFunction","what":"Matrices list filtration","title":"HicAggR - In depth tutorial","text":"","code":"FilterInteractions(     matrices      = interactions_RFmatrix_ctrl.lst,     targets        = targets,     selectionFun     = NULL     ) |> str() #> List of 4 #>  $ anchor.Beaf.name: int [1:3] 1 3 4 #>  $ bait.Tss.name   : int [1:3] 1 2 3 #>  $ name            : int 1 #>  $ distance        : int [1:25] 1 3 8 24 38 49 63 65 80 102 ..."},{"path":"/articles/InDepth.html","id":"tips-5","dir":"Articles","previous_headings":"Filtrations","what":"Tips","title":"HicAggR - In depth tutorial","text":"Filter GInteraction object allows intersect selected index. Filter matrices list without selection better filter interaction attributes matrices list","code":""},{"path":"/articles/InDepth.html","id":"selection-function-tips-and-examples","dir":"Articles","previous_headings":"Filtrations > Tips","what":"Selection function tips and examples:","title":"HicAggR - In depth tutorial","text":"common , B C /B /C common B, C common B, plus present C common C elements present B Everything present B C present ","code":"a <- c(\"A\",\"B\",\"D\",\"G\") b <- c(\"E\",\"B\",\"C\",\"G\") c <- c(\"A\",\"F\",\"C\",\"G\") Reduce(intersect, list(a,b,c)) |> sort() #> [1] \"G\" intersect(a,b) |> intersect(c) |> sort() #> [1] \"G\" Reduce(union, list(a,b,c)) |> sort() #> [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" union(a,b) |> union(c) |> sort() #> [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" Reduce(setdiff,list(a,b,c)) |> sort() #> [1] \"D\" setdiff(a,b) |> setdiff(c) |> sort() #> [1] \"D\" intersect(a,b) |> setdiff(c) |> sort() #> [1] \"B\" intersect(a,b) |> union(c) |> sort() #> [1] \"A\" \"B\" \"C\" \"F\" \"G\" union(a,b) |> intersect(c) |> sort() #> [1] \"A\" \"C\" \"G\" union(a,b) |> setdiff(c) |> sort() #> [1] \"B\" \"D\" \"E\" d <- c(a,b,c) setdiff(d,d[duplicated(d)]) |> sort() #> [1] \"D\" \"E\" \"F\""},{"path":"/articles/InDepth.html","id":"orientation","dir":"Articles","previous_headings":"","what":"Orientation","title":"HicAggR - In depth tutorial","text":"ExtractSubmatrix returns submatrices orientated according 5’->3’ orientation chromosome. case heterotypic asymetric pairs (anchor != bait), anchors baits thus mixed Y X axis matrices.  OrientateMatrix function allows force matrices orientated way anchors systematically Y axis baits X axis.","code":""},{"path":"/articles/InDepth.html","id":"information-about-the-orientation","dir":"Articles","previous_headings":"Orientation","what":"Information about the orientation","title":"HicAggR - In depth tutorial","text":"13th matrice well oriented, .e. anchor Beaf Y axis bait TSS X axis 14th matrice well oriented, .e. bait TSS Y axis anchor Beaf X axis","code":"# mcols(attributes(     # first100_interactions_RFmatrix_ctrl.lst)$interactions)$orientation"},{"path":"/articles/InDepth.html","id":"orientation-on-matrices-list","dir":"Articles","previous_headings":"Orientation","what":"Orientation on matrices list","title":"HicAggR - In depth tutorial","text":"","code":"oriented_first100_interactions_RFmatrix_ctrl.lst <-      OrientateMatrix(first100_interactions_RFmatrix_ctrl.lst) #> 58 matrices are oriented"},{"path":"/articles/InDepth.html","id":"orientation-of-one-matrix-only-","dir":"Articles","previous_headings":"Orientation","what":"Orientation of one matrix only.","title":"HicAggR - In depth tutorial","text":"Warning procedure force orientation even needed.","code":"orientedMatrix.mtx <-      OrientateMatrix(first100_interactions_RFmatrix_ctrl.lst[[1]])"},{"path":"/articles/InDepth.html","id":"prepare-matrices-list","dir":"Articles","previous_headings":"","what":"Prepare matrices list","title":"HicAggR - In depth tutorial","text":"PrepareMtxList can used perform operations matrices list. function prepares matrices list performing per matrix operation transforming values. example values can quantilized inorder rank local interactions highlight contacts highest values. function can also used correct orientations, just OrientateMatrix. reason giving access user originally hidden function uniformly prepared matrices list quantifications visualisations.","code":"oriented_quantiled_first100_interactions_RFmatrix_ctrl.lst <-      PrepareMtxList(         first100_interactions_RFmatrix_ctrl.lst,         transFun = 'quantile',         orientate = TRUE) #> 58 matrices are oriented oriented_first100_interactions_RFmatrix_ctrl.lst <-      PrepareMtxList(         first100_interactions_RFmatrix_ctrl.lst,         orientate = TRUE) #> 58 matrices are oriented"},{"path":"/articles/InDepth.html","id":"quantifications","dir":"Articles","previous_headings":"","what":"Quantifications","title":"HicAggR - In depth tutorial","text":"GetQuantif function takes input list submatrices returns vector contact frequencies given typeof regions contacts computed function.","code":""},{"path":"/articles/InDepth.html","id":"basic-quantifications","dir":"Articles","previous_headings":"Quantifications","what":"Basic quantifications","title":"HicAggR - In depth tutorial","text":"GetQuantif function extracts per submatrix average values 3*3 central pixels default (see GetQuantif). area: region contacts values extracted matrix. operation function done extracted values matrix. Example: Average values centered 3x3 square.","code":"center.num <- GetQuantif(     matrices  = oriented_first100_interactions_RFmatrix_ctrl.lst,     areaFun      = \"center\",     operationFun = \"mean\"     )"},{"path":"/articles/InDepth.html","id":"custom-functions","dir":"Articles","previous_headings":"Quantifications","what":"Custom functions","title":"HicAggR - In depth tutorial","text":"GetQuantif function also takes custom area operation parameter. area: function defining submatrix coordinates values extracted matrices. operation function defining operation done extracted values matrices. Example: Interactions values matrice.mtx[33:35,67:69] area, averaged removing zeros.","code":"GetQuantif(     matrices  = oriented_first100_interactions_RFmatrix_ctrl.lst,     areaFun      = function(matrice.mtx){matrice.mtx[33:35,67:69]},     operationFun = function(area.mtx){         area.mtx[which(area.mtx==0)]<-NA;         return(mean(area.mtx,na.rm=TRUE))         }     ) |> c() |> unlist() |> head() #>   2L:74_2L:77 2L:115_2L:107 2L:121_2L:107 2L:121_2L:117 2L:274_2L:268  #>     1.1964916     0.7079941     0.3850699     0.5802793     0.1114877  #> 2L:278_2L:268  #>     0.1286555"},{"path":[]},{"path":"/articles/InDepth.html","id":"values-naming","dir":"Articles","previous_headings":"Quantifications > Particular cases:","what":"Values naming","title":"HicAggR - In depth tutorial","text":"default, returned values named submatrix ID. varName set element metadata column name GInteraction attributes, values returned values named according element. Example: Named quantifications anchor.Beaf.name Note changing submatrix ID names can create name duplicates: Example: 46th matrix correspond two Beaf32 peaks, .e. two anchor.Beaf.name consequence, value center.num duplicated namedCenter.num Duplicated value index stored attributes.","code":"namedCenter.num <- GetQuantif(     matrices  = oriented_first100_interactions_RFmatrix_ctrl.lst,     areaFun      = \"center\",     operationFun = \"mean\",     varName      = \"anchor.Beaf.name\"     ) unlist(c(center.num))[45:50] #> 2L:5909_2L:5941 2L:5944_2L:5968 2L:5945_2L:5968 2L:6051_2L:6069 2L:6066_2L:6069  #>       0.6376167       0.6754207       0.6832946       0.6930854       1.2542497  #> 2L:6084_2L:6071  #>       0.8629411 unlist(c(namedCenter.num))[45:51] #> Beaf32_15 Beaf32_15 Beaf32_39 Beaf32_41 Beaf32_62 Beaf32_62 Beaf32_62  #> 0.6250402 0.6376167 0.6754207 0.6832946 0.6930854 1.2542497 0.8629411 attributes(center.num)$duplicated #> NULL attributes(namedCenter.num)$duplicated #> [1] 16"},{"path":"/articles/InDepth.html","id":"one-value-extraction","dir":"Articles","previous_headings":"Quantifications > Particular cases:","what":"One value extraction","title":"HicAggR - In depth tutorial","text":"","code":"GetQuantif(     matrices  = oriented_first100_interactions_RFmatrix_ctrl.lst,     areaFun      = function(matrice.mtx){matrice.mtx[5,5]},     operationFun = function(area.mtx){area.mtx}     ) |> head() #>   2L:74_2L:77 2L:115_2L:107 2L:121_2L:107 2L:121_2L:117 2L:274_2L:268  #>     0.5192703     0.3471995     0.7177761     0.5917856     0.5535116  #> 2L:278_2L:268  #>     0.6732039"},{"path":"/articles/InDepth.html","id":"area-extraction","dir":"Articles","previous_headings":"Quantifications > Particular cases:","what":"Area extraction","title":"HicAggR - In depth tutorial","text":"","code":"GetQuantif(     matrices  = oriented_first100_interactions_RFmatrix_ctrl.lst,     areaFun      = function(matrice.mtx){matrice.mtx[4:6,4:6]},     operationFun = function(area){area}     ) |> head() #>   2L:74_2L:77 2L:115_2L:107 2L:121_2L:107 2L:121_2L:117 2L:274_2L:268  #>     0.5401282            NA            NA     0.5621180     0.5192703  #> 2L:278_2L:268  #>            NA"},{"path":"/articles/InDepth.html","id":"tips-6","dir":"Articles","previous_headings":"Quantifications","what":"Tips","title":"HicAggR - In depth tutorial","text":"operationFun NULL return values selected region without NA.","code":"GetQuantif(     matrices  = oriented_first100_interactions_RFmatrix_ctrl.lst,     areaFun      = function(matrice.mtx){matrice.mtx[4:6,4:6]},     operationFun = NULL     ) |> head() #>   2L:74_2L:77 2L:115_2L:107 2L:121_2L:107 2L:121_2L:117 2L:274_2L:268  #>     0.5401282     0.5621180     0.5192703     0.5841077     0.5451626  #> 2L:278_2L:268  #>     0.5062174"},{"path":"/articles/InDepth.html","id":"aggregations","dir":"Articles","previous_headings":"","what":"Aggregations","title":"HicAggR - In depth tutorial","text":"Aggregation function takes input list submatrices returns aggregated matrix using aggregation function defined user.","code":""},{"path":[]},{"path":"/articles/InDepth.html","id":"basic-aggregation","dir":"Articles","previous_headings":"Aggregations > One sample aggregation","what":"Basic aggregation","title":"HicAggR - In depth tutorial","text":"Aggregation function default aggregation functions like sum, mean median (see Aggregation)","code":"# rm0 argument can be added to PrepareMtxList to assign NA to 0 values. oriented_first100_interactions_RFmatrix_ctrl.lst =      PrepareMtxList(         oriented_first100_interactions_RFmatrix_ctrl.lst,         rm0 = FALSE) agg_sum.mtx <- Aggregation(     matrices = oriented_first100_interactions_RFmatrix_ctrl.lst,      aggFun      = \"sum\"     )"},{"path":"/articles/InDepth.html","id":"custom-aggregation","dir":"Articles","previous_headings":"Aggregations > One sample aggregation","what":"Custom aggregation","title":"HicAggR - In depth tutorial","text":"Defining custom aggregation function: example shows mean function removing NA.","code":"agg_mean.mtx <- Aggregation(     matrices = oriented_first100_interactions_RFmatrix_ctrl.lst,     aggFun      = function(x){mean(x,na.rm=TRUE)}     )"},{"path":"/articles/InDepth.html","id":"two-samples-differential-aggregation","dir":"Articles","previous_headings":"Aggregations","what":"Two samples differential aggregation","title":"HicAggR - In depth tutorial","text":"Aggregation function can take input two list submatrices two samples conditions returns differential aggregated matrix. Two ways obtain differential aggregation applied, first assessing differences individual pairs submatrices aggregate differences; second aggregating matrices assess differences aggregated matrices (see examples ).","code":""},{"path":"/articles/InDepth.html","id":"preparation-of-matrices-list","dir":"Articles","previous_headings":"Aggregations > Two samples differential aggregation","what":"Preparation of matrices list","title":"HicAggR - In depth tutorial","text":"Preparation Control matrices list conditionFiltration Orientation Preparation second matrices list Beaf depleted condition. Extraction Filtration Orientation","code":"first100_targets = list(     submatrix.name = names(interactions_RFmatrix_ctrl.lst)[1:100]     ) first100_interactions_RFmatrix_ctrl.lst <- FilterInteractions(     matrices  = interactions_RFmatrix_ctrl.lst,     targets    = first100_targets,     selectionFun = NULL     ) oriented_first100_interactions_RFmatrix_ctrl.lst <-      OrientateMatrix(first100_interactions_RFmatrix_ctrl.lst) interactions_RFmatrix.lst  <- ExtractSubmatrix(     genomicFeature         = interactions.gni,     hicLst        = HiC_HS.cmx_lst,     referencePoint = \"rf\",     matriceDim     = 101     ) first100_interactions_RFmatrix.lst <- FilterInteractions(     matrices  = interactions_RFmatrix.lst,     targets    = first100_targets,     selectionFun = NULL     ) oriented_first100_interactions_RFmatrix.lst <-      OrientateMatrix(first100_interactions_RFmatrix.lst) #> 58 matrices are oriented"},{"path":"/articles/InDepth.html","id":"aggregate","dir":"Articles","previous_headings":"Aggregations > Two samples differential aggregation","what":"Aggregate","title":"HicAggR - In depth tutorial","text":"","code":"oriented_first100_interactions_RFmatrix_ctrl.lst =      PrepareMtxList(first100_interactions_RFmatrix_ctrl.lst,         minDist   = NULL,         maxDist   = NULL,         rm0       = FALSE,         orientate = TRUE ) #> 58 matrices are oriented oriented_first100_interactions_RFmatrix.lst =      PrepareMtxList(first100_interactions_RFmatrix.lst,         minDist   = NULL,         maxDist   = NULL,         rm0       = FALSE,         orientate = TRUE ) #> 58 matrices are oriented  diffAggreg.mtx <- Aggregation(     ctrlMatrices    = oriented_first100_interactions_RFmatrix_ctrl.lst,     matrices        = oriented_first100_interactions_RFmatrix.lst,     aggFun             = \"mean\",     diffFun            = \"substraction\",     scaleCorrection = TRUE,     correctionArea  =  list(         i = c(1:30),         j = c(72:101)         ),     statCompare = TRUE)"},{"path":"/articles/InDepth.html","id":"tips-7","dir":"Articles","previous_headings":"Aggregations","what":"Tips","title":"HicAggR - In depth tutorial","text":"PrepareMtxList function: PrepareMtxList acts one stop function perform value treatment orientation correction allowing consistent matrices list quantification visualization process come. rm0 TRUE zeros matrices list replaced NA. possible filter submatrices list minimal maximal distance aggregation function. possible orientate submatrices point using OrientateMatrix function. totalMatrixNumber: total number matrices. filteredMatrixNumber: number matrices distance filtering. minimalDistance: minimal distance anchor bait. maximalDistance: maximal distance anchor bait. transformationMethod: function used perform per matrix data transformation. zeroRemoved: Boolean indicates zeros replaced NA. Aggregation function: aggregation performed using one sample , use either matrices ctrlMatrices parameters statCompare may set TRUE every time (due memory requirement). aggregationMethod: function applied obtain aggregation. correctedFact: value added condition reduce noise. ’s computed median difference condition control background area (e.g upper right corner matrices). agg: Aggregation condition. aggCtrl: Aggregation control. aggCorrected: Aggregation condition corrected correctedFact. aggDelta: difference aggregated matrix condition aggregated matrix control. aggCorrectedDelta: difference aggregated matrix condition corrected correctedFact aggregated matrix control.","code":""},{"path":[]},{"path":"/articles/InDepth.html","id":"preparation-of-aggregated-matrices","dir":"Articles","previous_headings":"Aggregations plots","what":"Preparation of aggregated matrices","title":"HicAggR - In depth tutorial","text":"Control aggregation orientation Control aggregation orientation Differential aggregation","code":"aggreg.mtx <- Aggregation(         ctrlMatrices=interactions_RFmatrix_ctrl.lst,         aggFun=\"mean\" ) oriented_interactions_RFmatrix_ctrl.lst <-      OrientateMatrix(interactions_RFmatrix_ctrl.lst) #> 168 matrices are oriented orientedAggreg.mtx <- Aggregation(         ctrlMatrices=oriented_interactions_RFmatrix_ctrl.lst,         aggFun=\"mean\" ) oriented_interactions_RFmatrix.lst <-      OrientateMatrix(interactions_RFmatrix.lst) #> 168 matrices are oriented diffAggreg.mtx <- Aggregation(         ctrlMatrices    = oriented_interactions_RFmatrix_ctrl.lst,         matrices        = oriented_interactions_RFmatrix.lst,         aggFun          = \"mean\",         diffFun         = \"log2+1\",         scaleCorrection = TRUE,         correctionArea  = list( i=c(1:30) , j=c(72:101) ),         statCompare     = TRUE )"},{"path":[]},{"path":[]},{"path":"/articles/InDepth.html","id":"with-no-orientation","dir":"Articles","previous_headings":"Aggregations plots > Plots > Simple aggregation plot:","what":"With no orientation","title":"HicAggR - In depth tutorial","text":"ggAPA function creates ggplot object (ggplot2::geom_raster) #### Orientation ### visualisation parameters:","code":"ggAPA(         aggregatedMtx   = aggreg.mtx,         title = \"APA\" ) ggAPA(         aggregatedMtx   = orientedAggreg.mtx,         title = \"APA\" )"},{"path":"/articles/InDepth.html","id":"trimming-aggregated-values-for-visualisation","dir":"Articles","previous_headings":"Aggregations plots > Plots > Simple aggregation plot:","what":"Trimming aggregated values for visualisation:","title":"HicAggR - In depth tutorial","text":"possible set specific range values scale, remove percentage values using upper tail, lower tail tails distribution.","code":"ggAPA(         aggregatedMtx      = aggreg.mtx,         title    = \"APA 30% trimmed on upper side\",         trim = 30,         tails   = \"upper\" ) #> Warning in max(unlist(bounds.num_lst[1]), na.rm = TRUE): no non-missing #> arguments to max; returning -Inf ggAPA(         aggregatedMtx      = aggreg.mtx,         title    = \"APA 30% trimmed on upper side\",         trim = 30,         tails   = \"lower\" ) #> Warning in min(unlist(bounds.num_lst[2]), na.rm = TRUE): no non-missing #> arguments to min; returning Inf ggAPA(         aggregatedMtx      = aggreg.mtx,         title    = \"APA 30% trimmed\",         trim = 30,         tails   = \"both\" )"},{"path":[]},{"path":"/articles/InDepth.html","id":"min-and-max-color-scale","dir":"Articles","previous_headings":"","what":"HicAggR - In depth tutorial","title":"HicAggR - In depth tutorial","text":"Example user-defined min max color scale","code":"ggAPA(         aggregatedMtx         = aggreg.mtx,         title       = \"APA [0-1]\",         colMin = 0,         colMax = 1 )"},{"path":"/articles/InDepth.html","id":"center-color-scale","dir":"Articles","previous_headings":"","what":"HicAggR - In depth tutorial","title":"HicAggR - In depth tutorial","text":"Example user-defined color scale center","code":"ggAPA(         aggregatedMtx    = aggreg.mtx,         title  = \"APA center on 0.2\",         colMid = 0.5 )"},{"path":"/articles/InDepth.html","id":"change-color-breaks","dir":"Articles","previous_headings":"","what":"HicAggR - In depth tutorial","title":"HicAggR - In depth tutorial","text":"Examples user-defined color breaks","code":"ggAPA(         aggregatedMtx       = aggreg.mtx,         title     = \"APA [0, .25, .50, .30, .75, 1]\",         colBreaks = c(0,0.25,0.5,0.75,1) ) ggAPA(         aggregatedMtx       = aggreg.mtx,         title     = \"APA [0, .15, .20, .25, 1]\",         colBreaks = c(0,0.15,0.20,0.25,1) ) ggAPA(         aggregatedMtx       = aggreg.mtx,         title     = \"APA [0, .5, .6, .8, 1]\",         colBreaks = c(0,0.4,0.5,0.7,1) )"},{"path":"/articles/InDepth.html","id":"change-color-scale-bias","dir":"Articles","previous_headings":"","what":"HicAggR - In depth tutorial","title":"HicAggR - In depth tutorial","text":"Examples different color scaled bias.","code":"ggAPA(         aggregatedMtx    = aggreg.mtx,         title  = \"APA\",         colorScale = \"density\" ) ggAPA(         aggregatedMtx     = aggreg.mtx,         title   = \"APA\",         bias    = 2 ) ggAPA(         aggregatedMtx     = aggreg.mtx,         title   = \"APA\",         bias    = 0.5 )"},{"path":"/articles/InDepth.html","id":"change-color","dir":"Articles","previous_headings":"","what":"HicAggR - In depth tutorial","title":"HicAggR - In depth tutorial","text":"option change color heatmap color NA values.","code":"ggAPA(         aggregatedMtx     = aggreg.mtx,         title   = \"APA\",         colors = viridis(6),         na.value      = \"black\" )"},{"path":"/articles/InDepth.html","id":"blurred-visualization","dir":"Articles","previous_headings":"Aggregations plots > Plots > Simple aggregation plot:","what":"Blurred visualization","title":"HicAggR - In depth tutorial","text":"Option apply blurr heatmap reduce noise.","code":"ggAPA(         aggregatedMtx           = aggreg.mtx,         title         = \"APA\",         blurPass      = 1,         stdev        = 0.5,         loTri      = NA )"},{"path":"/articles/InDepth.html","id":"ggplot-object-modifications","dir":"Articles","previous_headings":"Aggregations plots > Plots > Simple aggregation plot:","what":"ggplot object modifications","title":"HicAggR - In depth tutorial","text":"Since ggAPA() returns ggplot object, possible modify following ggplot2 grammar","code":"ggAPA(         aggregatedMtx     = aggreg.mtx,         title   = \"APA\", ) +  ggplot2::labs(         title    = \"New title\",         subtitle = \"and subtitle\" )"},{"path":"/articles/InDepth.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"HicAggR - In depth tutorial","text":"","code":"sessionInfo() #> R version 4.3.3 (2024-02-29) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] HicAggR_0.99.3 #>  #> loaded via a namespace (and not attached): #>  [1] tidyselect_1.2.1            viridisLite_0.4.2           #>  [3] dplyr_1.1.4                 farver_2.1.1                #>  [5] bitops_1.0-7                fastmap_1.1.1               #>  [7] RCurl_1.98-1.14             reshape_0.8.9               #>  [9] digest_0.6.35               lifecycle_1.0.4             #> [11] magrittr_2.0.3              compiler_4.3.3              #> [13] rlang_1.1.3                 sass_0.4.9                  #> [15] tools_4.3.3                 utf8_1.2.4                  #> [17] yaml_2.3.8                  data.table_1.15.2           #> [19] knitr_1.45                  S4Arrays_1.2.1              #> [21] labeling_0.4.3              DelayedArray_0.28.0         #> [23] plyr_1.8.9                  xml2_1.3.6                  #> [25] abind_1.4-5                 BiocParallel_1.36.0         #> [27] withr_3.0.0                 purrr_1.0.2                 #> [29] BiocGenerics_0.48.1         desc_1.4.3                  #> [31] grid_4.3.3                  stats4_4.3.3                #> [33] fansi_1.0.6                 colorspace_2.1-0            #> [35] Rhdf5lib_1.24.2             ggplot2_3.5.0               #> [37] scales_1.3.0                SummarizedExperiment_1.32.0 #> [39] cli_3.6.2                   rmarkdown_2.26              #> [41] crayon_1.5.2                ragg_1.3.0                  #> [43] generics_0.1.3              rstudioapi_0.16.0           #> [45] cachem_1.0.8                rhdf5_2.46.1                #> [47] stringr_1.5.1               zlibbioc_1.48.2             #> [49] parallel_4.3.3              XVector_0.42.0              #> [51] matrixStats_1.2.0           vctrs_0.6.5                 #> [53] Matrix_1.6-5                jsonlite_1.8.8              #> [55] IRanges_2.36.0              S4Vectors_0.40.2            #> [57] systemfonts_1.0.6           strawr_0.0.91               #> [59] jquerylib_0.1.4             tidyr_1.3.1                 #> [61] glue_1.7.0                  pkgdown_2.0.7               #> [63] codetools_0.2-19            stringi_1.8.3               #> [65] gtable_0.3.4                GenomeInfoDb_1.38.8         #> [67] GenomicRanges_1.54.1        munsell_0.5.0               #> [69] tibble_3.2.1                pillar_1.9.0                #> [71] htmltools_0.5.8             rhdf5filters_1.14.1         #> [73] GenomeInfoDbData_1.2.11     R6_2.5.1                    #> [75] textshaping_0.3.7           evaluate_0.23               #> [77] kableExtra_1.4.0            lattice_0.22-5              #> [79] Biobase_2.62.0              highr_0.10                  #> [81] memoise_2.0.1               bslib_0.6.2                 #> [83] Rcpp_1.0.12                 InteractionSet_1.30.0       #> [85] svglite_2.1.3               gridExtra_2.3               #> [87] SparseArray_1.2.4           xfun_0.43                   #> [89] fs_1.6.3                    MatrixGenerics_1.14.0       #> [91] pkgconfig_2.0.3"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nicolas Chanard. Author. David Depierre. Author. Robel Tesfaye. Author, contributor. Naomi Schickele. Contributor. Refka Askri. Contributor. Pascal Martin. Contributor. Stephane Schaak. Author, contributor. Olivier Cuvier. Maintainer, contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chanard et al. 2024 HicAggR: Set 3D genomic interaction analysis tools.","code":"@Manual{,   author = {Nicolas Chanard and David Depierre and Robel A Tesfaye and Naomi Schickele and Refka Askri and Pascal Martin and Stephane Schaak and Olivier Cuvier},   title = {HicAggR: Set of 3D genomic interaction analysis tools.},   year = {2024},   url = {https://cuvierlab.github.io/HicAggR/},   url = {https://github.com/CuvierLab/HicAggR}, }"},{"path":"/index.html","id":"hicaggr-","dir":"","previous_headings":"","what":"Set of 3D genomic interaction analysis tools","title":"Set of 3D genomic interaction analysis tools","text":"package provides set functions useful analysis 3D genomic interactions. includes import standard HiC data formats R HiC normalisation procedures. main objective package improve visualization quantification analysis HiC contacts aggregation.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Set of 3D genomic interaction analysis tools","text":"Development version avalaible GitHub:","code":"remotes::install_github(\"CuvierLab/HicAggR\")"},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Set of 3D genomic interaction analysis tools","text":"HicAggR","code":""},{"path":"/reference/Aggregation.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregation of matrices list. — Aggregation","title":"Aggregation of matrices list. — Aggregation","text":"Aggregates matrices list (two lists case differential aggregation) single matrix. function allows apply different aggregation (average, sum, ...), differential (subtraction, ratio, ...) functions.","code":""},{"path":"/reference/Aggregation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregation of matrices list. — Aggregation","text":"","code":"Aggregation(   ctrlMatrices = NULL,   matrices = NULL,   aggFun = \"mean\",   diffFun = \"substraction\",   scaleCorrection = FALSE,   correctionArea = NULL,   statCompare = FALSE )"},{"path":"/reference/Aggregation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregation of matrices list. — Aggregation","text":"ctrlMatrices <listmatrix>: matrices list aggregate control. matrices <listmatrix>: matrices list aggregate. aggFun : function used aggregate pixel matrix. parameter character : \"50%\" \"median\" apply median \"+\" \"sum\" apply sum (Default) apply mean diffFun : function used compute differential. parameter character : \"-\", \"substract\" \"substraction\" apply substraction \"/\" \"ratio\" apply ratio \"log2\",\"log2-\",\"log2/\" \"log2ratio\" apply log2 ratio (Default) apply log2 1+ratio scaleCorrection : Whether correction done median value take ane noising area. (Default TRUE) correctionArea : Nested list indice define noising area fore correction. List must contain first element \"\" (row indices) element called \"j\" (columns indices). NULL automatically take upper left part aggregated matrices. (Default NULL) statCompare : Whether t.test must apply pixel differential aggregated matrix.","code":""},{"path":"/reference/Aggregation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregation of matrices list. — Aggregation","text":"matrix","code":""},{"path":"/reference/Aggregation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregation of matrices list. — Aggregation","text":"Aggregation","code":""},{"path":"/reference/Aggregation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregation of matrices list. — Aggregation","text":"","code":"# Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst) data(HiC_HS.cmx_lst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(seqnames = c(\"2L\", \"2R\"),          seqlengths = c(23513712, 25286936)),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) # subset 2000 first for exemple Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)]  # Matrices extractions center on Beaf32 <-> Beaf32 point interaction interactions_Ctrl.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" ) interactions_HS.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_HS.cmx_lst,     referencePoint = \"pf\" ) interactions_Ctrl.mtx_lst <- PrepareMtxList(     matrices = interactions_Ctrl.mtx_lst )  # Aggregate matrices in one matrix aggreg.mtx <- Aggregation(interactions_Ctrl.mtx_lst)   interactions_HS.mtx_lst <- PrepareMtxList(     matrices = interactions_HS.mtx_lst )  # Differential Aggregation aggregDiff.mtx <- Aggregation(     ctrlMatrices = interactions_Ctrl.mtx_lst,     matrices = interactions_HS.mtx_lst )"},{"path":"/reference/BalanceHiC.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute HiC matrix-balancing. — BalanceHiC","title":"Compute HiC matrix-balancing. — BalanceHiC","text":"Apply matrix-balancing normalization method list contacts matrix.","code":""},{"path":"/reference/BalanceHiC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute HiC matrix-balancing. — BalanceHiC","text":"","code":"BalanceHiC(   hicLst,   method = \"ICE\",   interactionType = NULL,   maxIter = 50,   qtlTh = 0.15,   cores = 1,   verbose = FALSE )"},{"path":"/reference/BalanceHiC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute HiC matrix-balancing. — BalanceHiC","text":"hicLst <ListContactMatrix>: HiC maps list. method : kind normalization method. One \"ICE\", \"VC\" \"VC_SQRT\" (Default \"ICE\") interactionType : \"cis\", \"trans\", c(\"cis\", \"trans\"), \"\". NULL normalization apply cis contactMatrix trans contactMatrix (equivalent c(\"cis\", \"trans\")). \"\", normalization apply contactMatrix . (Default NULL) maxIter : maximum iteration number. qtlTh : quantile threshold bins ignored. (Default 0.15) cores : Number cores used. (Default 1) verbose : TRUE show progression console. (Default FALSE)","code":""},{"path":"/reference/BalanceHiC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute HiC matrix-balancing. — BalanceHiC","text":"matrices list.","code":""},{"path":"/reference/BalanceHiC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute HiC matrix-balancing. — BalanceHiC","text":"BalanceHiC","code":""},{"path":"/reference/BalanceHiC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute HiC matrix-balancing. — BalanceHiC","text":"","code":"data(HiC_Ctrl.cmx_lst)  HiC_Ctrl_ICE.cmx_lst <- BalanceHiC(HiC_Ctrl.cmx_lst,     interactionType = \"cis\",     method = \"ICE\" )  HiC_Ctrl_VC.cmx_lst <- BalanceHiC(HiC_Ctrl.cmx_lst,     interactionType = c(\"cis\", \"trans\"),     method = \"VC\" )  HiC_Ctrl_VC_SQRT.cmx_lst <- BalanceHiC(HiC_Ctrl.cmx_lst,     interactionType = \"all\",     method = \"VC_SQRT\" )"},{"path":"/reference/Beaf32_Peaks.gnr.html","id":null,"dir":"Reference","previous_headings":"","what":"D.melanogaster Beaf-32 ChIP-seq. — Beaf32_Peaks.gnr","title":"D.melanogaster Beaf-32 ChIP-seq. — Beaf32_Peaks.gnr","text":"Drosophila Melanogaster Beaf32 peaks 2L 2R chromosomes.","code":""},{"path":"/reference/Beaf32_Peaks.gnr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"D.melanogaster Beaf-32 ChIP-seq. — Beaf32_Peaks.gnr","text":"","code":"data(Beaf32_Peaks.gnr)"},{"path":"/reference/Beaf32_Peaks.gnr.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"D.melanogaster Beaf-32 ChIP-seq. — Beaf32_Peaks.gnr","text":"object class GRanges.","code":""},{"path":"/reference/Beaf32_Peaks.gnr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"D.melanogaster Beaf-32 ChIP-seq. — Beaf32_Peaks.gnr","text":"","code":"data(Beaf32_Peaks.gnr) Beaf32_Peaks.gnr #> GRanges object with 600 ranges and 2 metadata columns: #>         seqnames            ranges strand |     score        name #>            <Rle>         <IRanges>  <Rle> | <numeric> <character> #>     [1]       2L       35594-35725      * |        76    Beaf32_2 #>     [2]       2L       47296-47470      * |        44    Beaf32_3 #>     [3]       2L       65770-65971      * |       520    Beaf32_5 #>     [4]       2L       73858-74052      * |       205    Beaf32_8 #>     [5]       2L     102138-102684      * |      1830   Beaf32_11 #>     ...      ...               ...    ... .       ...         ... #>   [596]       2R 24687286-24687440      * |        37 Beaf32_2943 #>   [597]       2R 24874870-24875019      * |        82 Beaf32_2958 #>   [598]       2R 24944555-24944686      * |        48 Beaf32_2966 #>   [599]       2R 24969405-24969744      * |      1068 Beaf32_2971 #>   [600]       2R 25038610-25038711      * |        76 Beaf32_2975 #>   ------- #>   seqinfo: 2 sequences from an unspecified genome; no seqlengths"},{"path":"/reference/BinGRanges.html","id":null,"dir":"Reference","previous_headings":"","what":"Bin a GRanges. — BinGRanges","title":"Bin a GRanges. — BinGRanges","text":"Bin GRanges apply summary method (e.g: 'mean', 'median', 'sum', 'max, 'min' ...) chosen numerical variable ranges bin.","code":""},{"path":"/reference/BinGRanges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bin a GRanges. — BinGRanges","text":"","code":"BinGRanges(   gRange = NULL,   chromSizes = NULL,   binSize = NULL,   method = \"mean\",   metadataColName = NULL,   na.rm = TRUE,   cores = 1,   reduceRanges = TRUE,   verbose = FALSE )"},{"path":"/reference/BinGRanges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bin a GRanges. — BinGRanges","text":"gRange : GRanges bin. chromSizes <data.frame>: data.frame first colum corresponds chromosomes names, second column corresponds chromosomes lengths base pairs. binSize : Width bins. method : Name summary method 'mean', 'median', 'sum', 'max, 'min'. (Default 'mean') metadataColName : character vector specify metadata columns GRanges apply summary method. na.rm : logical value indicating whether NA values stripped computation proceeds. (Default TRUE) cores : number cores. (Default 1) reduceRanges : Whether duplicated Bins must reduced summary method (method arg). (Default TRUE) verbose : TRUE, show progression console. (Default FALSE)","code":""},{"path":"/reference/BinGRanges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bin a GRanges. — BinGRanges","text":"binned GRanges.","code":""},{"path":"/reference/BinGRanges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bin a GRanges. — BinGRanges","text":"BinGRanges","code":""},{"path":"/reference/BinGRanges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bin a GRanges. — BinGRanges","text":"","code":"GRange.gnr <- GenomicRanges::GRanges(     seqnames = S4Vectors::Rle(c(\"chr1\", \"chr2\"), c(3, 1)),     ranges = IRanges::IRanges(         start = c(1, 201, 251, 1),         end = c(200, 250, 330, 100),         names = letters[seq_len(4)]     ),     strand = S4Vectors::Rle(BiocGenerics::strand(c(\"*\")), 4),     score = c(50, NA, 100, 30) ) GRange.gnr #> GRanges object with 4 ranges and 1 metadata column: #>     seqnames    ranges strand |     score #>        <Rle> <IRanges>  <Rle> | <numeric> #>   a     chr1     1-200      * |        50 #>   b     chr1   201-250      * |        NA #>   c     chr1   251-330      * |       100 #>   d     chr2     1-100      * |        30 #>   ------- #>   seqinfo: 2 sequences from an unspecified genome; no seqlengths BinGRanges(     gRange = GRange.gnr,     chromSizes = data.frame(c(\"chr1\", \"chr2\"), c(350, 100)),     binSize = 100,     method = \"mean\",     metadataColName = \"score\",     na.rm = TRUE ) #> GRanges object with 5 ranges and 2 metadata columns: #>       seqnames    ranges strand |     score         bin #>          <Rle> <IRanges>  <Rle> | <numeric> <character> #>   [1]     chr1     1-100      * |        50      chr1:1 #>   [2]     chr1   101-200      * |        50      chr1:2 #>   [3]     chr1   201-300      * |       100      chr1:3 #>   [4]     chr1   301-350      * |       100      chr1:4 #>   [5]     chr2     1-100      * |        30      chr2:1 #>   ------- #>   seqinfo: 2 sequences from an unspecified genome"},{"path":"/reference/CutHiC.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut HiC map in chunks. — CutHiC","title":"Cut HiC map in chunks. — CutHiC","text":"Cut mega contactMatrix (joint multiple chromosomic maps) list contactMatrix.","code":""},{"path":"/reference/CutHiC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut HiC map in chunks. — CutHiC","text":"","code":"CutHiC(megaHic, verbose = FALSE)"},{"path":"/reference/CutHiC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut HiC map in chunks. — CutHiC","text":"megaHic : HiC megamap. verbose : TRUE, show progression console. (Default FALSE)","code":""},{"path":"/reference/CutHiC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut HiC map in chunks. — CutHiC","text":"matrices list.","code":""},{"path":"/reference/CutHiC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut HiC map in chunks. — CutHiC","text":"CutHiC","code":""},{"path":"/reference/CutHiC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut HiC map in chunks. — CutHiC","text":"","code":"data(HiC_Ctrl.cmx_lst) Mega_Ctrl.cmx <- JoinHiC(HiC_Ctrl.cmx_lst) CutHiC(Mega_Ctrl.cmx) #> $`2L_2L` #> class: ContactMatrix  #> dim: 236 236  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 236 #>  #> $`2L_2R` #> class: ContactMatrix  #> dim: 236 253  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 489 #>  #> $`2R_2R` #> class: ContactMatrix  #> dim: 253 253  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 253 #>  #> attr(,\"resolution\") #> [1] 1e+05 #> attr(,\"mtx\") #> [1] \"obs\" #> attr(,\"chromSize\") #> # A tibble: 2 × 3 #>   name    length dimension #>   <chr>    <dbl>     <dbl> #> 1 2L    23513712       236 #> 2 2R    25286936       253 #> attr(,\"matricesKind\") #> # A tibble: 3 × 4 #>   name  type  kind  symmetric #>   <chr> <chr> <chr> <lgl>     #> 1 2L_2L cis   U     TRUE      #> 2 2L_2R trans NA    FALSE     #> 3 2R_2R cis   U     TRUE"},{"path":"/reference/ExtractSubmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Submatrix extraction. — ExtractSubmatrix","title":"Submatrix extraction. — ExtractSubmatrix","text":"Extract matrices HiC maps list around genomic features.","code":""},{"path":"/reference/ExtractSubmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Submatrix extraction. — ExtractSubmatrix","text":"","code":"ExtractSubmatrix(   genomicFeature = NULL,   hicLst = NULL,   referencePoint = \"pf\",   hicResolution = NULL,   matriceDim = 21,   shift = 1,   remove_duplicates = TRUE,   cores = 1,   verbose = FALSE )"},{"path":"/reference/ExtractSubmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Submatrix extraction. — ExtractSubmatrix","text":"genomicFeature <GRanges PairsGRanges GInteractions>: genomic coordinates compute extraction HiC submatrix. hicLst <ListContactMatrix>: HiC maps list. referencePoint : Type extracted submatrices. \"rf\" \"region feature\" extract triangle-shaped matrices around regions \"pf\" \"point feature\" extract square-shaped matrices around points. (Default \"rf\") hicResolution : resolution used hicLst. NULL, automatically find resolution attributes hicLst. (Default NULL) matriceDim : size matrices output. (Default 21). shift : \"referencePoint\" \"rf\". Factor defining much distance anchor bait extracted region (Default 1). Ex: shift=2, extracted matrices : 2*regionSize+regionSize+2*regionSize. remove_duplicates : remove duplicated submatrices ? avoids duplicated submatrices anchor bait bins feature. ex. BEAF32-BEAF32, submatrix twice opposite orientations(Default TRUE) cores : integer specify number cores. (Default 1) verbose : TRUE, show progression console. (Default FALSE)","code":""},{"path":"/reference/ExtractSubmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Submatrix extraction. — ExtractSubmatrix","text":"matrices list.","code":""},{"path":"/reference/ExtractSubmatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Submatrix extraction. — ExtractSubmatrix","text":"ExtractSubmatrix","code":""},{"path":"/reference/ExtractSubmatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Submatrix extraction. — ExtractSubmatrix","text":"","code":"# Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)] # subset 2000 first for exemple  # Matrices extractions of regions defined between # Beaf32 <-> Beaf32 interactions interactions_RF.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"rf\" ) #> Warning: GRanges object contains 1862 out-of-bound ranges located on sequence #>   2L. Note that ranges located on a sequence whose length is unknown (NA) #>   or on a circular sequence are not considered out-of-bound (use #>   seqlengths() and isCircular() to get the lengths and circularity flags #>   of the underlying sequences). You can use trim() to trim these ranges. #>   See ?`trim,GenomicRanges-method` for more information. #> Warning: GRanges object contains 3724 out-of-bound ranges located on sequence #>   2L. Note that ranges located on a sequence whose length is unknown (NA) #>   or on a circular sequence are not considered out-of-bound (use #>   seqlengths() and isCircular() to get the lengths and circularity flags #>   of the underlying sequences). You can use trim() to trim these ranges. #>   See ?`trim,GenomicRanges-method` for more information.  # Matrices extractions center on Beaf32 <-> Beaf32 pointinteraction interactions_PF.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" )"},{"path":"/reference/FilterInteractions.html","id":null,"dir":"Reference","previous_headings":"","what":"Submatrix or Interactions filtering. — FilterInteractions","title":"Submatrix or Interactions filtering. — FilterInteractions","text":"Search GInteraction object interactions correspond target list return list index filter matrices list according target selectionFunction.","code":""},{"path":"/reference/FilterInteractions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Submatrix or Interactions filtering. — FilterInteractions","text":"","code":"FilterInteractions(   matrices = NULL,   genomicInteractions = NULL,   targets = NULL,   selectionFun = function() {      Reduce(intersect, interarctions.ndx_lst)  } )"},{"path":"/reference/FilterInteractions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Submatrix or Interactions filtering. — FilterInteractions","text":"matrices <Listmatrix>: matrices list filter. NULL, function return filtred matrices list, else return list index. genomicInteractions : GInteraction object compute filter. targets : named list describe target. selectionFun : function defines target variables must crossed. (Default intersection targets)","code":""},{"path":"/reference/FilterInteractions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Submatrix or Interactions filtering. — FilterInteractions","text":"list elements index filtred matrices list attributes updates.","code":""},{"path":"/reference/FilterInteractions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Submatrix or Interactions filtering. — FilterInteractions","text":"FilterInteractions","code":""},{"path":"/reference/FilterInteractions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Submatrix or Interactions filtering. — FilterInteractions","text":"","code":"# Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes  = data.frame(seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)),     binSize    = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)] # subset 2000 first for exemple  # Matrices extractions center on Beaf32 <-> Beaf32 point interaction interactions_PF.mtx_lst  <- ExtractSubmatrix(     genomicFeature         = Beaf_Beaf.gni,     hicLst        = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" )  # Create a target targets <- list(     anchor.Beaf.name = c(\"Beaf32_108\", \"Beaf32_814\"),     distance         = function(dist) {         dist < 300000     } ) # We target the Beaf32<->Beaf32 interactions that are less than 300Kb away # and have peak Beaf32_2 and Beaf32_191 as anchors (i.e. left).  # Create a selection selectionFun <- function() {     intersect(anchor.Beaf.name, distance) } # We select the Beaf32<->Beaf32 interactions that satisfy both targeting # criteria (intersection).  # Filtration on InteractionSet (Beaf32 <-> Beaf32 Pairs) FilterInteractions(     genomicInteractions = Beaf_Beaf.gni,     targets        = targets,     selectionFun     = NULL ) |> str(max.level = 1) #> List of 2 #>  $ anchor.Beaf.name: int [1:29] 9 77 145 213 281 349 417 485 553 621 ... #>  $ distance        : int [1:41] 1 2 137 138 139 273 274 275 276 410 ... # Returns a named list (the names match the targeting criteria). # Each element is an index vector of Beaf32<->Beaf32 interactions # that satisfy the given criteria.  # Filtration on Matrices List (Beaf32 <-> Beaf32 Extracted matrices) FilterInteractions(     matrices      = interactions_PF.mtx_lst,     targets        = targets,     selectionFun     = NULL ) |> str(max.level = 1) #> List of 2 #>  $ anchor.Beaf.name: int [1:6] 68 191 313 434 554 673 #>  $ distance        : int [1:6] 1 370 491 492 611 612 # Return the same kind of result.  # Add the selection on InteractionSet Filtration FilterInteractions(     genomicInteractions = Beaf_Beaf.gni,     targets = targets,     selectionFun = selectionFun ) |> str(max.level = 1) #>  int [1:2] 1097 1370 # This return the intersection of the index vector that satisfy both # targeting criteria.  # Add the selection on Matrices List Filtration FilterInteractions(     matrices = interactions_PF.mtx_lst,     targets = targets,     selectionFun = selectionFun ) |> str(max.level = 1) #>  Named list() #>  - attr(*, \"interactions\")=Formal class 'GInteractions' [package \"InteractionSet\"] with 6 slots #>  - attr(*, \"resolution\")= num 1e+05 #>  - attr(*, \"referencePoint\")= chr \"pf\" #>  - attr(*, \"matriceDim\")= num 21 #>  - attr(*, \"target\")=List of 2 #>  - attr(*, \"selection\")=function ()   #>   ..- attr(*, \"srcref\")= 'srcref' int [1:8] 35 17 37 1 17 1 35 37 #>   .. ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55c6689e5c28>  # This return the filtred matrices, i.e the matrices for which # the Beaf32<->Beaf32 interactions satisfy both targeting criteria.  # Filtration with InteractionsSet as filtration criteria targets <- list(interactions = Beaf_Beaf.gni[seq_len(2)]) FilterInteractions(     genomicInteractions = Beaf_Beaf.gni,     targets = targets,     selectionFun = NULL ) |> str(max.level = 1) #>  Named int [1:4] 1 2 137 273 #>  - attr(*, \"names\")= chr [1:4] \"interactions1\" \"interactions2\" \"interactions3\" \"interactions4\"   # Filtration with GRanges as filtration criteria targets <- list(first =     InteractionSet::anchors(Beaf_Beaf.gni)[[\"first\"]][seq_len(2)]) FilterInteractions(     genomicInteractions = Beaf_Beaf.gni,     targets = targets,     selectionFun = NULL ) |> str(max.level = 1) #>  Named int [1:28] 1 2 138 274 410 411 546 547 682 683 ... #>  - attr(*, \"names\")= chr [1:28] \"first1\" \"first2\" \"first3\" \"first4\" ..."},{"path":"/reference/GenomicSystem.html","id":null,"dir":"Reference","previous_headings":"","what":"Base pairs convertion. — GenomicSystem","title":"Base pairs convertion. — GenomicSystem","text":"Convert numbers base string order magnitude (Kbp, Mbp, Gbp) vice versa.","code":""},{"path":"/reference/GenomicSystem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Base pairs convertion. — GenomicSystem","text":"","code":"GenomicSystem(x, digits = 3)"},{"path":"/reference/GenomicSystem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Base pairs convertion. — GenomicSystem","text":"x : number convert string convert. digits : number significant digits used. See signif() informations. (Default 3)","code":""},{"path":"/reference/GenomicSystem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Base pairs convertion. — GenomicSystem","text":"converted number string.","code":""},{"path":"/reference/GenomicSystem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Base pairs convertion. — GenomicSystem","text":"GenomicSystem","code":""},{"path":"/reference/GenomicSystem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Base pairs convertion. — GenomicSystem","text":"","code":"GenomicSystem(1540, 3) #> [1] \"1.54Kbp\" GenomicSystem(1540, 2) #> [1] \"1.5Kbp\" GenomicSystem(\"1Mbp\") #> [1] 1e+06 GenomicSystem(\"1Kbp\") #> [1] 1000 GenomicSystem(\"1k\") #> [1] 1000"},{"path":"/reference/GetQuantif.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute quantification on extracted submatrices. — GetQuantif","title":"Compute quantification on extracted submatrices. — GetQuantif","text":"Function computes quantification contact frequencies given area returns named vector.","code":""},{"path":"/reference/GetQuantif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute quantification on extracted submatrices. — GetQuantif","text":"","code":"GetQuantif(   matrices,   areaFun = \"center\",   operationFun = \"mean_rm0\",   varName = NULL )"},{"path":"/reference/GetQuantif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute quantification on extracted submatrices. — GetQuantif","text":"matrices <Listmatrix>: matrices list. areaFun : character function allows extract area matrix composes matrices list (Default \"center\"). \"C\" \"CENTER\": 3x3 pixels intersection anchor bait. \"UL\" \"UPPER_LEFT\": pixels uppper left square \"UR\" \"UPPER_RIGHT\": pixels uppper right square \"BL\" \"BOTTOM_LEFT\": pixels bottom left square \"BR\" \"BOTTOM_RIGHT\": pixels bottom right square \"U\" \"UPPER\": pixels center area \"B\" \"BOTTOM\": pixels center area \"L\" \"LEFT\": pixels left center area \"R\" \"RIGHT\": pixels right center area \"D\" \"DONUT\": pixels surrounds center area operationFun : character function specifying operation applied selected area. (Default \"mean_rm0\") \"mean_rm0\": apply mean replacing 0 NA \"median_rm0\": apply median replacing 0 NA \"sum_rm0\": apply sum replacing 0 NA \"median\": apply median \"sum\": apply sum \"mean\" character: apply mean varName : name column GInteraction attributes matrices used named output vector (Default NULL). default, sub-matrices IDs used.","code":""},{"path":"/reference/GetQuantif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute quantification on extracted submatrices. — GetQuantif","text":"GRange object.","code":""},{"path":"/reference/GetQuantif.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute quantification on extracted submatrices. — GetQuantif","text":"GetQuantif","code":""},{"path":"/reference/GetQuantif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute quantification on extracted submatrices. — GetQuantif","text":"","code":"# Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(         seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)     ),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)] # subset 2000 first for exemple  # Matrices extractions center on Beaf32 <-> Beaf32 point interaction interactions_PF.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" ) GetQuantif(     matrices = interactions_PF.mtx_lst,     areaFun = \"center\",     operationFun = \"mean\" ) |> head() #> 2L:11_2L:12 2L:11_2L:17 2L:11_2L:20 2L:11_2L:22 2L:11_2L:23 2L:11_2L:24  #>  31422.8750   1866.5556    779.7778    788.0000    760.1111    554.1111"},{"path":"/reference/HiC_Ctrl.cmx_lst.html","id":null,"dir":"Reference","previous_headings":"","what":"In situ Hi-C control. — HiC_Ctrl.cmx_lst","title":"In situ Hi-C control. — HiC_Ctrl.cmx_lst","text":"situ Hi-C non-heat treated S2 cells (Drosophila Melanogaster) MboI chromosome 2R 2L download 4DN portal (Ray J, Munn PR, et al., 2019). data result ImportHiC() function.","code":""},{"path":"/reference/HiC_Ctrl.cmx_lst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"In situ Hi-C control. — HiC_Ctrl.cmx_lst","text":"","code":"data(HiC_Ctrl.cmx_lst)"},{"path":"/reference/HiC_Ctrl.cmx_lst.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"In situ Hi-C control. — HiC_Ctrl.cmx_lst","text":"list ContactMatrix objects. element correspond interaction matrix two chromosomes.","code":""},{"path":"/reference/HiC_Ctrl.cmx_lst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"In situ Hi-C control. — HiC_Ctrl.cmx_lst","text":"","code":"data(HiC_Ctrl.cmx_lst) HiC_Ctrl.cmx_lst #> $`2L_2L` #> class: ContactMatrix  #> dim: 236 236  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 236 #>  #> $`2L_2R` #> class: ContactMatrix  #> dim: 236 253  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 489 #>  #> $`2R_2R` #> class: ContactMatrix  #> dim: 253 253  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 253 #>  #> attr(,\"resolution\") #> [1] 1e+05 #> attr(,\"chromSize\") #> # A tibble: 2 × 3 #>   name    length dimension #>   <chr>    <dbl>     <dbl> #> 1 2L    23513712       236 #> 2 2R    25286936       253 #> attr(,\"matricesKind\") #> # A tibble: 3 × 4 #>   name  type  kind  symmetric #>   <chr> <chr> <chr> <lgl>     #> 1 2L_2L cis   U     TRUE      #> 2 2L_2R trans NA    FALSE     #> 3 2R_2R cis   U     TRUE      #> attr(,\"mtx\") #> [1] \"obs\""},{"path":"/reference/HiC_HS.cmx_lst.html","id":null,"dir":"Reference","previous_headings":"","what":"In situ Hi-C heat treated. — HiC_HS.cmx_lst","title":"In situ Hi-C heat treated. — HiC_HS.cmx_lst","text":"situ Hi-C heat treated S2 cells (Drosophila Melanogaster) MboI chromosome 2R 2L download 4DN portal (Ray J, Munn PR, et al., 2019). data result ImportHiC() function.","code":""},{"path":"/reference/HiC_HS.cmx_lst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"In situ Hi-C heat treated. — HiC_HS.cmx_lst","text":"","code":"data(HiC_HS.cmx_lst)"},{"path":"/reference/HiC_HS.cmx_lst.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"In situ Hi-C heat treated. — HiC_HS.cmx_lst","text":"list ContactMatrix objects. element correspond interaction matrix two chromosomes.","code":""},{"path":"/reference/HiC_HS.cmx_lst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"In situ Hi-C heat treated. — HiC_HS.cmx_lst","text":"","code":"data(HiC_HS.cmx_lst) HiC_HS.cmx_lst #> $`2L_2L` #> class: ContactMatrix  #> dim: 236 236  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 236 #>  #> $`2L_2R` #> class: ContactMatrix  #> dim: 236 253  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 489 #>  #> $`2R_2R` #> class: ContactMatrix  #> dim: 253 253  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(5): name type kind symmetric resolution #> regions: 253 #>  #> attr(,\"resolution\") #> [1] 1e+05 #> attr(,\"chromSize\") #> # A tibble: 2 × 3 #>     length name  dimension #>      <int> <chr>     <dbl> #> 1 23513712 2L          236 #> 2 25286936 2R          253 #> attr(,\"matricesKind\") #> # A tibble: 3 × 4 #>   name  type  kind  symmetric #>   <chr> <chr> <chr> <lgl>     #> 1 2L_2L cis   U     TRUE      #> 2 2L_2R trans NA    FALSE     #> 3 2R_2R cis   U     TRUE      #> attr(,\"mtx\") #> [1] \"obs\""},{"path":"/reference/HicAggR-package.html","id":null,"dir":"Reference","previous_headings":"","what":"HicAggR — HicAggR-package","title":"HicAggR — HicAggR-package","text":"HicAggR package allows integrate 1D genomics data 3D genomics data. package provides set functions useful analysis 3D genomic interactions. includes import standard HiC data formats R HiC normalisation procedures. main objective package facilitate visualization quantification analysis HiC contacts aggregation. package also provides options import externally normalized HiC data perform -depth analysis investigating genome wide interactions features interest. package can use 1D genomics data (annotation data peaks features interest GRanges object) form potential couples features interest user specified constraints (TADs coordinates fixed minimum/max distance). Using formed couples can extract HiC contact data specific couples. submatrices extracted can aggregated summarize genome-wide interactions, perform per submatrix operation compare conditions. also allows identify couples significantly signal-enriched pixels specific positions (central pixel) relative background less plausible couples.","code":""},{"path":[]},{"path":"/reference/HicAggR-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"HicAggR — HicAggR-package","text":"Nicolas Chanard David Depierre Robel Tesfaye Naomi Schickele Refka Askri Pascal Martin Stéphane Schaack Olivier Cuvier","code":""},{"path":"/reference/Hue.html","id":null,"dir":"Reference","previous_headings":"","what":"Hue palette. — Hue","title":"Hue palette. — Hue","text":"Create Hue palette.","code":""},{"path":"/reference/Hue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hue palette. — Hue","text":"","code":"Hue(   paletteLength = 9,   rotation = NULL,   hueRange = c(0, 360),   saturation = 0.65,   lightness = 0.65,   alphaValue = 1,   alpha = FALSE )"},{"path":"/reference/Hue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hue palette. — Hue","text":"paletteLength : Color number. rotation : positive, rotates clockwise color space, reversing number negative. NULL, compute rotation according hueRange parameter. (Default NULL) hueRange : Degree range color space 0 360. (Default c(0,360)) saturation : Saturation value 0 1. (Default 0.65) lightness : Lightness value 0 1. (Default 0.65) alphaValue : Opacity value 0 1. (Default 1) alpha : Whether alpha layer returned. (Default FALSE)","code":""},{"path":"/reference/Hue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hue palette. — Hue","text":"vector color.","code":""},{"path":"/reference/Hue.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hue palette. — Hue","text":"Hue","code":""},{"path":"/reference/Hue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hue palette. — Hue","text":"","code":"Hue(paletteLength = 9) #> [1] \"#e06c6c\" \"#e0b96c\" \"#b9e06c\" \"#6ce06c\" \"#6ce0b9\" \"#6cbae0\" \"#6c6ce0\" #> [8] \"#b86ce0\" \"#e06cba\""},{"path":"/reference/ICEnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Iterative Correction. — ICEnorm","title":"Compute Iterative Correction. — ICEnorm","text":"Compute Iterative Correction (Vanilla Count) hic maps.","code":""},{"path":"/reference/ICEnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Iterative Correction. — ICEnorm","text":"","code":"ICEnorm(hic, qtlTh = 0.15, maxIter = 50)"},{"path":"/reference/ICEnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Iterative Correction. — ICEnorm","text":"hic : HiC maps chunk normalize. qtlTh : threshold quantile bins ignored. (Default 0.15) maxIter : maximum iteration number.","code":""},{"path":"/reference/ICEnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Iterative Correction. — ICEnorm","text":"normalized contactMatrix","code":""},{"path":"/reference/ICEnorm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Iterative Correction. — ICEnorm","text":"ICEnorm","code":""},{"path":"/reference/ICEnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Iterative Correction. — ICEnorm","text":"","code":"data(HiC_Ctrl.cmx_lst) HiC_Ctrl_ICE.cmx <- ICEnorm(HiC_Ctrl.cmx_lst[['2L_2L']])"},{"path":"/reference/ImportHiC.html","id":null,"dir":"Reference","previous_headings":"","what":"Import Hic data — ImportHiC","title":"Import Hic data — ImportHiC","text":"Import ..hic, .cool, .mcool .bedpe data","code":""},{"path":"/reference/ImportHiC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import Hic data — ImportHiC","text":"","code":"ImportHiC(   file = NULL,   hicResolution = NULL,   chromSizes = NULL,   chrom_1 = NULL,   chrom_2 = NULL,   verbose = FALSE,   cores = 1,   hic_norm = \"NONE\",   hic_matrix = \"observed\",   cool_balanced = FALSE,   cool_weight_name = \"weight\",   cool_divisive_weights = FALSE,   h5_fill_upper = TRUE )"},{"path":"/reference/ImportHiC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import Hic data — ImportHiC","text":"file <GRanges PairsGRanges GInteractions>: genomic feature compute extraction HiC submatrix. Extension .hic, .cool, .mcool, .h5, .hdf5, .HDF5 .bedpe\" assuming .h5 .hdf5 cool (mcool). hicResolution : HiC resolution. chromSizes <data.frame>: data.frame first colum correspond chromosomes names, second column correspond chromosomes lengths base pairs. chrom_1 : seqnames first chromosmes (rows matrix). chrom_2 : seqnames second chromosmes (col matrix). NULL variable assigned value chrom_1 (Defalt NULL). verbose : Show progression console? (Default FALSE) cores : integer specify number cores. (Default 1) hic_norm : \"norm\" argument supply strawr::straw(). argument .hic format data . Available norms can obtained strawr::readHicNormTypes(). (Default \"NONE\"). hic_matrix : \"matrix\" argument supply strawr::straw(). argument .hic format data . options can : \"oe\", \"expected\". (Default \"observed\"). cool_balanced Import already balanced matrix? (Default: FALSE) cool_weight_name Name correcter cool file. (Default: weight). rhdf5::h5ls() see available correctors. cool_divisive_weights correcter vector contain divisive biases hicExplorer multiplicative cooltools? (Default: FALSE) h5_fill_upper matrix h5 format need transposed? (Default: TRUE)","code":""},{"path":"/reference/ImportHiC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import Hic data — ImportHiC","text":"matrices list.","code":""},{"path":"/reference/ImportHiC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Import Hic data — ImportHiC","text":"ImportHiC request \"expected\" values importing .hic format data, must \"oe\" importing manually observed counts well. Prior v.0.9.0 cooltools multiplicative weight , make sure correcters divisive multiplicative. https://cooler.readthedocs.io/en/stable/releasenotes.html#v0-9-0 loading hic matrix h5 format make sure enough momory load full matrix chromosomes regardless values chrom_1 chrom_2 arguments. function first loads whole matrix, extracts matrices per chromosome time , easier ;).","code":""},{"path":"/reference/ImportHiC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Import Hic data — ImportHiC","text":"","code":"# \\donttest{  # Prepare Temp Directory options(timeout = 3600) temp.dir <- file.path(tempdir(), \"HIC_DATA\") dir.create(temp.dir)  # Download .hic file Hic.url <- paste0(     \"https://4dn-open-data-public.s3.amazonaws.com/\",     \"fourfront-webprod/wfoutput/\",     \"7386f953-8da9-47b0-acb2-931cba810544/4DNFIOTPSS3L.hic\" ) HicOutput.pth <- file.path(temp.dir, \"Control_HIC.hic\") HicOutput.pth <- normalizePath(HicOutput.pth) #> Warning: path[1]=\"/tmp/RtmpHrmwC4/HIC_DATA/Control_HIC.hic\": No such file or directory if(.Platform$OS.type == \"windows\"){     download.file(Hic.url, HicOutput.pth, method = \"auto\",     extra = \"-k\",mode=\"wb\") }else{     download.file(Hic.url, HicOutput.pth, method = \"auto\", extra = \"-k\") }  # Import .hic file HiC_Ctrl.cmx_lst <- ImportHiC(     file = HicOutput.pth,     hicResolution = 100000,     chrom_1 = c(\"2L\", \"2L\", \"2R\"),     chrom_2 = c(\"2L\", \"2R\", \"2R\") )  # Download .mcool file Mcool.url <- paste0(     \"https://4dn-open-data-public.s3.amazonaws.com/\",     \"fourfront-webprod/wfoutput/\",     \"4f1479a2-4226-4163-ba99-837f2c8f4ac0/4DNFI8DRD739.mcool\" ) McoolOutput.pth <- file.path(temp.dir, \"HeatShock_HIC.mcool\") HicOutput.pth <- normalizePath(McoolOutput.pth) #> Warning: path[1]=\"/tmp/RtmpHrmwC4/HIC_DATA/HeatShock_HIC.mcool\": No such file or directory if(.Platform$OS.type == \"windows\"){     download.file(Mcool.url, McoolOutput.pth, method = \"auto\",     extra = \"-k\",mode=\"wb\") }else{     download.file(Mcool.url, McoolOutput.pth, method = \"auto\",     extra = \"-k\") }  # Import .mcool file HiC_HS.cmx_lst <- ImportHiC(     file = McoolOutput.pth,     hicResolution = 100000,     chrom_1 = c(\"2L\", \"2L\", \"2R\"),     chrom_2 = c(\"2L\", \"2R\", \"2R\") ) # } # Import .h5 file h5_path <- system.file(\"extdata\",     \"Control_HIC_10k_2L.h5\",     package = \"HicAggR\", mustWork = TRUE ) binSize=10000 hicLst <- ImportHiC(   file      = h5_path,   hicResolution       = binSize,   chromSizes = data.frame(seqnames = c(\"2L\"),    seqlengths = c(23513712)),   chrom_1   = c(\"2L\") )"},{"path":"/reference/IndexFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"Indexes GRanges on genome. — IndexFeatures","title":"Indexes GRanges on genome. — IndexFeatures","text":"Function indexes GRanges object binned genome constraints. Needed prior HicAggR::SearchPairs() function.","code":""},{"path":"/reference/IndexFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Indexes GRanges on genome. — IndexFeatures","text":"","code":"IndexFeatures(   gRangeList = NULL,   genomicConstraint = NULL,   chromSizes = NULL,   binSize = NULL,   method = \"mean\",   metadataColName = NULL,   cores = 1,   verbose = FALSE )"},{"path":"/reference/IndexFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Indexes GRanges on genome. — IndexFeatures","text":"gRangeList <GRanges GRangesList listGRanges>: GRanges object, list GRanges GRangesList containing coordinates index. genomicConstraint : GRanges object constraint regions. Note bins constraint region paired HicAggR::SearchPairs(). NULL chromosomes chromSizes used constraints (Default NULL) chromSizes <data.frame>: data.frame containing chromosomes names lengths base pairs (see example). binSize : Bin size bp - corresponds matrix resolution. method : string defining summary method used metadata columns defined metadataColName multiple ranges indexed bin. Use 'mean', 'median', 'sum', 'max' 'min'. (Default 'mean'') metadataColName : character vector specify metadata columns GRanges apply summary method multiple ranges indexed bin. cores : Number cores used. (Default 1) verbose : Show progression console? (Default FALSE)","code":""},{"path":"/reference/IndexFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Indexes GRanges on genome. — IndexFeatures","text":"GRanges object.","code":""},{"path":"/reference/IndexFeatures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Indexes GRanges on genome. — IndexFeatures","text":"IndexFeatures","code":""},{"path":"/reference/IndexFeatures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Indexes GRanges on genome. — IndexFeatures","text":"","code":"data(Beaf32_Peaks.gnr) Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(         seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)     ),     binSize = 100000 )"},{"path":"/reference/JoinHiC.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge HiC chunk. — JoinHiC","title":"Merge HiC chunk. — JoinHiC","text":"Create mega contactMatrix list contactMatrix.","code":""},{"path":"/reference/JoinHiC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge HiC chunk. — JoinHiC","text":"","code":"JoinHiC(hicLst)"},{"path":"/reference/JoinHiC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge HiC chunk. — JoinHiC","text":"hicLst <ListContactMatrix>: HiC maps list.","code":""},{"path":"/reference/JoinHiC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge HiC chunk. — JoinHiC","text":"ContactMatrix.","code":""},{"path":"/reference/JoinHiC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge HiC chunk. — JoinHiC","text":"JoinHiC","code":""},{"path":"/reference/JoinHiC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge HiC chunk. — JoinHiC","text":"","code":"data(HiC_Ctrl.cmx_lst) Mega_Ctrl.cmx <- JoinHiC(HiC_Ctrl.cmx_lst)"},{"path":"/reference/MergeGRanges.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge GRanges. — MergeGRanges","title":"Merge GRanges. — MergeGRanges","text":"Merge GRanges list GRanges","code":""},{"path":"/reference/MergeGRanges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge GRanges. — MergeGRanges","text":"","code":"MergeGRanges(..., sortRanges = FALSE, reduceRanges = FALSE)"},{"path":"/reference/MergeGRanges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge GRanges. — MergeGRanges","text":"... <GRanges GRangesList listGRanges>: GRanges list GRanges GRangesList. sortRanges : Whether result sorted. (Default FALSE) reduceRanges : Whether result reduced. See GenomicRanges::reduce details. (Default FALSE)","code":""},{"path":"/reference/MergeGRanges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge GRanges. — MergeGRanges","text":"GRange object.","code":""},{"path":"/reference/MergeGRanges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge GRanges. — MergeGRanges","text":"MergeGRanges","code":""},{"path":"/reference/MergeGRanges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge GRanges. — MergeGRanges","text":"","code":"GRange_1.grn <- GenomicRanges::GRanges(     seqnames = S4Vectors::Rle(c(\"chr1\", \"chr2\", \"chr1\"), c(1, 3, 1)),     ranges = IRanges::IRanges(101:105, end = 111:115,         names = letters[seq_len(5)]),     strand = S4Vectors::Rle(BiocGenerics::strand(c(\"-\", \"+\", \"*\", \"+\")),         c(1, 1, 2, 1)),     score = seq_len(5) ) GRange_2.grn <- GenomicRanges::GRanges(     seqnames = S4Vectors::Rle(c(\"chr1\", \"chr3\"), c(1, 4)),     ranges = IRanges::IRanges(106:110, end = 116:120, names = letters[6:10]),     strand = S4Vectors::Rle(BiocGenerics::strand(c(\"*\", \"+\", \"-\")),         c(2, 1, 2)),     score = 6:10 ) GRange_1.grn #> GRanges object with 5 ranges and 1 metadata column: #>     seqnames    ranges strand |     score #>        <Rle> <IRanges>  <Rle> | <integer> #>   a     chr1   101-111      - |         1 #>   b     chr2   102-112      + |         2 #>   c     chr2   103-113      * |         3 #>   d     chr2   104-114      * |         4 #>   e     chr1   105-115      + |         5 #>   ------- #>   seqinfo: 2 sequences from an unspecified genome; no seqlengths GRange_2.grn #> GRanges object with 5 ranges and 1 metadata column: #>     seqnames    ranges strand |     score #>        <Rle> <IRanges>  <Rle> | <integer> #>   f     chr1   106-116      * |         6 #>   g     chr3   107-117      * |         7 #>   h     chr3   108-118      + |         8 #>   i     chr3   109-119      - |         9 #>   j     chr3   110-120      - |        10 #>   ------- #>   seqinfo: 2 sequences from an unspecified genome; no seqlengths MergeGRanges(GRange_1.grn, GRange_2.grn) #> GRanges object with 10 ranges and 1 metadata column: #>     seqnames    ranges strand |     score #>        <Rle> <IRanges>  <Rle> | <integer> #>   a     chr1   101-111      - |         1 #>   b     chr2   102-112      + |         2 #>   c     chr2   103-113      * |         3 #>   d     chr2   104-114      * |         4 #>   e     chr1   105-115      + |         5 #>   f     chr1   106-116      * |         6 #>   g     chr3   107-117      * |         7 #>   h     chr3   108-118      + |         8 #>   i     chr3   109-119      - |         9 #>   j     chr3   110-120      - |        10 #>   ------- #>   seqinfo: 3 sequences from an unspecified genome; no seqlengths GRange.lst <- list(GRange_1.grn, GRange_2.grn) MergeGRanges(GRange.lst) #> GRanges object with 10 ranges and 1 metadata column: #>     seqnames    ranges strand |     score #>        <Rle> <IRanges>  <Rle> | <integer> #>   a     chr1   101-111      - |         1 #>   b     chr2   102-112      + |         2 #>   c     chr2   103-113      * |         3 #>   d     chr2   104-114      * |         4 #>   e     chr1   105-115      + |         5 #>   f     chr1   106-116      * |         6 #>   g     chr3   107-117      * |         7 #>   h     chr3   108-118      + |         8 #>   i     chr3   109-119      - |         9 #>   j     chr3   110-120      - |        10 #>   ------- #>   seqinfo: 3 sequences from an unspecified genome; no seqlengths MergeGRanges(GRange.lst, reduceRanges = TRUE) #> GRanges object with 8 ranges and 0 metadata columns: #>       seqnames    ranges strand #>          <Rle> <IRanges>  <Rle> #>   [1]     chr1   105-115      + #>   [2]     chr1   101-111      - #>   [3]     chr1   106-116      * #>   [4]     chr2   102-112      + #>   [5]     chr2   103-114      * #>   [6]     chr3   108-118      + #>   [7]     chr3   109-120      - #>   [8]     chr3   107-117      * #>   ------- #>   seqinfo: 3 sequences from an unspecified genome; no seqlengths"},{"path":"/reference/OrientateMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix orientation — OrientateMatrix","title":"Matrix orientation — OrientateMatrix","text":"Oriente extracted Matrix according anchors bait order. Apply 180° rotation follow transposation matrix matrices list according interactions attributes list.","code":""},{"path":"/reference/OrientateMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix orientation — OrientateMatrix","text":"","code":"OrientateMatrix(mtx, verbose = TRUE)"},{"path":"/reference/OrientateMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix orientation — OrientateMatrix","text":"mtx <matrix Listmatrix>: Matrix matricies list oriente verbose : Report number matrices corrected. (Default: TRUE)","code":""},{"path":"/reference/OrientateMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix orientation — OrientateMatrix","text":"Oriented matrix matricies list","code":""},{"path":"/reference/OrientateMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matrix orientation — OrientateMatrix","text":"OrientateMatrix","code":""},{"path":"/reference/OrientateMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix orientation — OrientateMatrix","text":"","code":"# Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst)  # Index Beaf32 in TADs domains Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(         seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)     ),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)] # subset 2000 first for exemple  # Matrices extractions center on Beaf32 <-> Beaf32 point interaction interactions_PF.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" )  # Matrices Orientation oriented_Interactions_PF.mtx_lst <- OrientateMatrix(interactions_PF.mtx_lst) #> 692 matrices are oriented"},{"path":"/reference/OverExpectedHiC.html","id":null,"dir":"Reference","previous_headings":"","what":"Genomic distance bias correction. — OverExpectedHiC","title":"Genomic distance bias correction. — OverExpectedHiC","text":"Function normalises HiC matrices expected values computed per genomic distance.","code":""},{"path":"/reference/OverExpectedHiC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genomic distance bias correction. — OverExpectedHiC","text":"","code":"OverExpectedHiC(   hicLst,   method = \"mean_non_zero\",   verbose = FALSE,   cores = 1,   plot_contact_vs_dist = \"per_seq\" )"},{"path":"/reference/OverExpectedHiC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Genomic distance bias correction. — OverExpectedHiC","text":"hicLst <ListContactMatrix>: HiC maps list. method Options \"mean_non_zero\", \"mean_total\", \"lieberman\". Look details . (Default: \"mean_non_zero\") verbose : Show progression console? (Default FALSE) cores : Number cores used. (Default 1) plot_contact_vs_dist Whether plot contact vs distance curve per chromosome (\"per_seq\"), chromosomes (\"total\") (NULL). (Default \"per_seq\")","code":""},{"path":"/reference/OverExpectedHiC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Genomic distance bias correction. — OverExpectedHiC","text":"matrices list.","code":""},{"path":"/reference/OverExpectedHiC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Genomic distance bias correction. — OverExpectedHiC","text":"OverExpectedHiC Methods calculate expected values per distance: \"mean_non_zero\": distance, average contact value calculated using non-zero values. \"mean_total\": distance, average contact value calculated using values distance. \"lieberman\": distance, contact values summed divided chromsome length minus distance. cis contacts.","code":""},{"path":"/reference/OverExpectedHiC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genomic distance bias correction. — OverExpectedHiC","text":"","code":"# Note: run HicAggR::BalanceHiC before OverExpectedHiC calculation. data(HiC_Ctrl.cmx_lst) OverExpectedHiC(HiC_Ctrl.cmx_lst)  #> $`2L_2L` #> class: ContactMatrix  #> dim: 236 236  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(6): name type ... resolution expected #> regions: 236 #>  #> $`2L_2R` #> class: ContactMatrix  #> dim: 236 253  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(6): name type ... resolution expected #> regions: 489 #>  #> $`2R_2R` #> class: ContactMatrix  #> dim: 253 253  #> type: dgCMatrix  #> rownames: NULL #> colnames: NULL #> metadata(6): name type ... resolution expected #> regions: 253 #>  #> attr(,\"resolution\") #> [1] 100000 #> attr(,\"chromSize\") #> # A tibble: 2 × 3 #>   name    length dimension #>   <chr>    <dbl>     <dbl> #> 1 2L    23513712       236 #> 2 2R    25286936       253 #> attr(,\"matricesKind\") #> # A tibble: 3 × 4 #>   name  type  kind  symmetric #>   <chr> <chr> <chr> <lgl>     #> 1 2L_2L cis   U     TRUE      #> 2 2L_2R trans NA    FALSE     #> 3 2R_2R cis   U     TRUE      #> attr(,\"mtx\") #> [1] \"o/e\" #> attr(,\"expected\") #> # A tibble: 253 × 2 #>    distance expected #>       <dbl>    <dbl> #>  1        1   44559. #>  2   100001   12794. #>  3   200001    3665. #>  4   300001    2130. #>  5   400001    1445. #>  6   500001    1092. #>  7   600001     876. #>  8   700001     739. #>  9   800001     625. #> 10   900001     550. #> # ℹ 243 more rows"},{"path":"/reference/PlotAPA.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw aggregation plot. — PlotAPA","title":"Draw aggregation plot. — PlotAPA","text":"Draw aggregation plot aggregation matrices.","code":""},{"path":"/reference/PlotAPA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw aggregation plot. — PlotAPA","text":"","code":"PlotAPA(   aggregatedMtx = NULL,   trim = 0,   colMin = NULL,   colMid = NULL,   colMax = NULL,   colMinCond = NULL,   colMaxCond = NULL,   extra_info = FALSE,   ... )"},{"path":"/reference/PlotAPA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw aggregation plot. — PlotAPA","text":"aggregatedMtx : aggregated matrix. trim : number 0 100 gives percentage triming matrices. colMin : minimal value color scale. Null automaticaly find. colMid : middle value color scale. Null automaticaly find. colMax : mximal value color scale. Null automaticaly find. colMinCond : Avalaible plotting differential aggregation. minimal value color scale classsical aggregation plot. NULL automaticaly find. colMaxCond : Avalaible plotting differantial aggregation. maxiaml value color scale classsical aggregation plot. NULL automaticaly find. extra_info want recall arguments values? (Default FALSE) ... additional arguments ggAPA()","code":""},{"path":"/reference/PlotAPA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw aggregation plot. — PlotAPA","text":"None","code":""},{"path":"/reference/PlotAPA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw aggregation plot. — PlotAPA","text":"PlotAPA","code":""},{"path":"/reference/PlotAPA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw aggregation plot. — PlotAPA","text":"","code":"# Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)] # subset 2000 first for exemple  # Matrices extractions center on Beaf32 <-> Beaf32 point interaction interactions_PF.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" )  # Aggregate matrices in one matrix aggreg.mtx <- Aggregation(interactions_PF.mtx_lst)  # Visualization PlotAPA(     aggregatedMtx = aggreg.mtx )   PlotAPA(     aggregatedMtx= aggreg.mtx,     trim= 20,     colMin= -2,     colMid= 0,     colMax= 2,     colMinCond = 0,     colMaxCond = 2 )"},{"path":"/reference/PlotAPA_byDistance.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw aggregation plots for interactions with different distances. — PlotAPA_byDistance","title":"Draw aggregation plots for interactions with different distances. — PlotAPA_byDistance","text":"Separates matrices based interaction distance, performs aggregation plots Aggregated signal chunk interaction distances.","code":""},{"path":"/reference/PlotAPA_byDistance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw aggregation plots for interactions with different distances. — PlotAPA_byDistance","text":"","code":"PlotAPA_byDistance(   submatrices = NULL,   ctrlSubmatrices = NULL,   ...,   plot.opts = NULL )"},{"path":"/reference/PlotAPA_byDistance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw aggregation plots for interactions with different distances. — PlotAPA_byDistance","text":"submatrices : matrices list separate using interaction distances aggregate. Chunks distances created : c(0,50000*2 ^ seq(0,5,=1)). matrices distances 1.6 Mb aggregated final chunk. ctrlSubmatrices : matrices list use control condition differential aggregation. ... : Additional arguments pass [Aggregation()]. differential aggregation plot, submatrices take matrices treated condition. eg:   plot.opts list arguments pass ggAPA().","code":"PlotAPA_byDistance( submatrices = interactions_HS.mtx_lst, ctrlSubmatrices = interactions_Ctrl.mtx_lst)```  [Aggregation()]: R:Aggregation()"},{"path":"/reference/PlotAPA_byDistance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw aggregation plots for interactions with different distances. — PlotAPA_byDistance","text":"plot separate APAs per distance list aggregated matrices invisible output.","code":""},{"path":"/reference/PlotAPA_byDistance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw aggregation plots for interactions with different distances. — PlotAPA_byDistance","text":"PlotAPA_byDistance","code":""},{"path":"/reference/PlotAPA_byDistance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw aggregation plots for interactions with different distances. — PlotAPA_byDistance","text":"","code":"#' # Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst) data(HiC_HS.cmx_lst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)] # subset 2000 first for eg  # Matrices extractions center on Beaf32 <-> Beaf32 point interaction interactions_Ctrl.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" ) interactions_HS.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_HS.cmx_lst,     referencePoint = \"pf\" ) interactions_Ctrl.mtx_lst <- PrepareMtxList(     matrices = interactions_Ctrl.mtx_lst )  # Aggregate matrices in one matrix PlotAPA_byDistance(submatrices = interactions_Ctrl.mtx_lst)    interactions_HS.mtx_lst <- PrepareMtxList(     matrices = interactions_HS.mtx_lst )  # Differential Aggregation PlotAPA_byDistance(     submatrices = interactions_HS.mtx_lst,     ctrlSubmatrices = interactions_Ctrl.mtx_lst,     diffFun = \"ratio\",     plot.opts = list(colors = list(\"blue\",\"white\",\"red\")) )"},{"path":"/reference/PrepareMtxList.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare matrices list for further analysis. — PrepareMtxList","title":"Prepare matrices list for further analysis. — PrepareMtxList","text":"Prepares matrices list analysis (eg. Aggregation GetQuantif). Orientation can corrected, per matrix transformation can performed.","code":""},{"path":"/reference/PrepareMtxList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare matrices list for further analysis. — PrepareMtxList","text":"","code":"PrepareMtxList(   matrices,   minDist = NULL,   maxDist = NULL,   rm0 = FALSE,   transFun = NULL,   orientate = FALSE )"},{"path":"/reference/PrepareMtxList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare matrices list for further analysis. — PrepareMtxList","text":"matrices <listmatrix>: matrices list prepare. minDist : minimal distance anchor bait. maxDist : maximal distance anchor bait. rm0 : Whether 0 replaced NA. (Default FALSE) transFun : function used transform scale values submatrix aggregation. following characters can submitted: \"quantile\" \"qtl\" apply function dplyr::ntile(x,500) \"percentile\" \"prct\" apply percentile. \"rank\" apply ranking. \"zscore\" apply scaling. \"minmax\" apply HicAggR::MinMaxScale. \"mu\" apply HicAggR::MeanScale. NULL apply transformation (Default). orientate : Whether matrices must corrected orientatation aggregation.","code":""},{"path":"/reference/PrepareMtxList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare matrices list for further analysis. — PrepareMtxList","text":"matrix list ready aggregation values extraction.","code":""},{"path":"/reference/PrepareMtxList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare matrices list for further analysis. — PrepareMtxList","text":"PrepareMtxList","code":""},{"path":"/reference/PrepareMtxList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare matrices list for further analysis. — PrepareMtxList","text":"","code":"# Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst) data(HiC_HS.cmx_lst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(seqnames = c(\"2L\", \"2R\"),           seqlengths = c(23513712, 25286936)),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)] # subset 2000 first for exemple  # Matrices extractions center on Beaf32 <-> Beaf32 point interaction interactions_Ctrl.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" ) interactions_HS.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_HS.cmx_lst,     referencePoint = \"pf\" ) interactions_Ctrl.mtx_lst <- PrepareMtxList(     matrices = interactions_Ctrl.mtx_lst )  # Aggregate matrices in one matrix aggreg.mtx <- Aggregation(interactions_Ctrl.mtx_lst)   interactions_HS.mtx_lst <- PrepareMtxList(     matrices = interactions_HS.mtx_lst )  # Differential Aggregation aggregDiff.mtx <- Aggregation(     ctrlMatrices = interactions_Ctrl.mtx_lst,     matrices = interactions_HS.mtx_lst )"},{"path":"/reference/QtlThreshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Find threshold for outliers based on quantiles. — QtlThreshold","title":"Find threshold for outliers based on quantiles. — QtlThreshold","text":"Find threshold outliers triming based quantiles.","code":""},{"path":"/reference/QtlThreshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find threshold for outliers based on quantiles. — QtlThreshold","text":"","code":"QtlThreshold(x = NULL, prctThr = 5, tails = \"both\")"},{"path":"/reference/QtlThreshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find threshold for outliers based on quantiles. — QtlThreshold","text":"x : Numeric vector. prctThr : Percentage (0-100) threshold. (Default 5) tails : Bounds return, \"lower\", \"upper\" \"\". (Default \"\")","code":""},{"path":"/reference/QtlThreshold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find threshold for outliers based on quantiles. — QtlThreshold","text":"Numerical vector thresholds values outliers triming.","code":""},{"path":"/reference/QtlThreshold.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find threshold for outliers based on quantiles. — QtlThreshold","text":"QtlThreshold","code":""},{"path":"/reference/QtlThreshold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find threshold for outliers based on quantiles. — QtlThreshold","text":"","code":"set.seed(1111) x <- 0:100 x <- sort(x) x #>   [1]   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17 #>  [19]  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 #>  [37]  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53 #>  [55]  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71 #>  [73]  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89 #>  [91]  90  91  92  93  94  95  96  97  98  99 100 QtlThreshold(x, prctThr = 5, tails = \"lower\") #> 5%     #>  5 NA  QtlThreshold(x, prctThr = 5, tails = \"both\") #>  2.5% 97.5%  #>   2.5  97.5  QtlThreshold(x, prctThr = 5, tails = \"upper\") #>     95%  #>  NA  95"},{"path":"/reference/ReduceRun.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function over two RLE — ReduceRun","title":"Apply a function over two RLE — ReduceRun","text":"Apply function values two RLE return one RLE.","code":""},{"path":"/reference/ReduceRun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function over two RLE — ReduceRun","text":"","code":"ReduceRun(firstRle, secondRle, reduceMethod = \"paste\", ...)"},{"path":"/reference/ReduceRun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function over two RLE — ReduceRun","text":"firstRle : First rle. secondRle >: Second rle. reduceMethod : Name function apply e.g paste, sum, mean. ... <...>: parameter reduce function.","code":""},{"path":"/reference/ReduceRun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function over two RLE — ReduceRun","text":"Reduced Rle","code":""},{"path":"/reference/ReduceRun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a function over two RLE — ReduceRun","text":"ReduceRun","code":""},{"path":"/reference/ResizeMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Resize a matrix — ResizeMatrix","title":"Resize a matrix — ResizeMatrix","text":"Resize numericam matrix new dimension.","code":""},{"path":"/reference/ResizeMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resize a matrix — ResizeMatrix","text":"","code":"ResizeMatrix(mtx, newDim = dim(mtx))"},{"path":"/reference/ResizeMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resize a matrix — ResizeMatrix","text":"mtx : numerical matrix resize. newDim : number rows cols resized matrix.","code":""},{"path":"/reference/ResizeMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resize a matrix — ResizeMatrix","text":"Resized matrix.","code":""},{"path":"/reference/ResizeMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Resize a matrix — ResizeMatrix","text":"ResizeMatrix","code":""},{"path":"/reference/SearchPairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates pairs from genomic index. — SearchPairs","title":"Creates pairs from genomic index. — SearchPairs","text":"Creates pairs coordinates indexed anchor bait genomic coordinates according distance constraints.","code":""},{"path":"/reference/SearchPairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates pairs from genomic index. — SearchPairs","text":"","code":"SearchPairs(   indexAnchor = NULL,   indexBait = NULL,   minDist = NULL,   maxDist = NULL,   exclude_self_interactions = TRUE,   verbose = FALSE,   cores = 1 )"},{"path":"/reference/SearchPairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates pairs from genomic index. — SearchPairs","text":"indexAnchor : first indexed GRanges object used pairs anchor (must indexed using IndexFeatures()). indexBait : second indexed GRanges object used pairs bait (must indexed using IndexFeatures()). NULL, indexAnchor used instead (Default NULL) minDist : Minimal distance anchors baits. (Default NULL) maxDist : Maximal distance anchors baits. (Default NULL) exclude_self_interactions pairs bin (\"2L:100_2L:100\") excluded? (Default: TRUE) verbose : Show progression console? (Default FALSE) cores : Number cores use. (Default 1)","code":""},{"path":"/reference/SearchPairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates pairs from genomic index. — SearchPairs","text":"GInteractions object.","code":""},{"path":"/reference/SearchPairs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates pairs from genomic index. — SearchPairs","text":"SearchPairs","code":""},{"path":"/reference/SearchPairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates pairs from genomic index. — SearchPairs","text":"","code":"# Data data(Beaf32_Peaks.gnr)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr)"},{"path":"/reference/SeqEnds.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all sequences lengths. — SeqEnds","title":"Get all sequences lengths. — SeqEnds","text":"Get sequences lengths ranges GRanges object.","code":""},{"path":"/reference/SeqEnds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all sequences lengths. — SeqEnds","text":"","code":"SeqEnds(gRanges)"},{"path":"/reference/SeqEnds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all sequences lengths. — SeqEnds","text":"gRanges : GRanges object.","code":""},{"path":"/reference/SeqEnds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all sequences lengths. — SeqEnds","text":"integer vector.","code":""},{"path":"/reference/SeqEnds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get all sequences lengths. — SeqEnds","text":"SeqEnds","code":""},{"path":"/reference/SeqEnds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get all sequences lengths. — SeqEnds","text":"","code":"GRange.grn <- GenomicRanges::GRanges(     seqnames = S4Vectors::Rle(c(\"chr1\", \"chr2\", \"chr1\"), c(1, 3, 1)),     ranges = IRanges::IRanges(101:105, end = 111:115,         names = letters[seq_len(5)]),     strand = S4Vectors::Rle(BiocGenerics::strand(c(\"-\", \"+\", \"*\", \"+\")),         c(1, 1, 2, 1)),     seqinfo = c(chr1 = 200, chr2 = 300),     score = seq_len(5) ) SeqEnds(GRange.grn) #> chr1 chr2 chr2 chr2 chr1  #>  200  300  300  300  200"},{"path":"/reference/StrToGRanges.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert String to GRanges. — StrToGRanges","title":"Convert String to GRanges. — StrToGRanges","text":"Convert ranges describe string (.e seqname:start-end:strand) GRanges object.","code":""},{"path":"/reference/StrToGRanges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert String to GRanges. — StrToGRanges","text":"","code":"StrToGRanges(stringRanges)"},{"path":"/reference/StrToGRanges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert String to GRanges. — StrToGRanges","text":"stringRanges : Strings convert GRanges.","code":""},{"path":"/reference/StrToGRanges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert String to GRanges. — StrToGRanges","text":"GRanges object.","code":""},{"path":"/reference/StrToGRanges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert String to GRanges. — StrToGRanges","text":"StrToGRanges","code":""},{"path":"/reference/StrToGRanges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert String to GRanges. — StrToGRanges","text":"","code":"StrToGRanges(\"chr1:1-100:+\") #> GRanges object with 1 range and 0 metadata columns: #>       seqnames    ranges strand #>          <Rle> <IRanges>  <Rle> #>   [1]     chr1     1-100      + #>   ------- #>   seqinfo: 1 sequence from an unspecified genome; no seqlengths StrToGRanges(c(\"chr1:1-100:+\", \"chr2:400-500:-\", \"chr1:10-50:*\")) #> GRanges object with 3 ranges and 0 metadata columns: #>       seqnames    ranges strand #>          <Rle> <IRanges>  <Rle> #>   [1]     chr1     1-100      + #>   [2]     chr2   400-500      - #>   [3]     chr1     10-50      * #>   ------- #>   seqinfo: 2 sequences from an unspecified genome; no seqlengths"},{"path":"/reference/SwitchMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Change values of HiC map. — SwitchMatrix","title":"Change values of HiC map. — SwitchMatrix","text":"Change values matrix observed, balanced, observed/expected expected values according done hic.","code":""},{"path":"/reference/SwitchMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change values of HiC map. — SwitchMatrix","text":"","code":"SwitchMatrix(hicLst, matrixKind = c(\"obs\", \"norm\", \"o/e\", \"exp\"))"},{"path":"/reference/SwitchMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change values of HiC map. — SwitchMatrix","text":"hicLst <ListContactMatrix>: HiC maps list. matrixKind : kind matrix want.","code":""},{"path":"/reference/SwitchMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change values of HiC map. — SwitchMatrix","text":"ContactMatrix list.","code":""},{"path":"/reference/SwitchMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change values of HiC map. — SwitchMatrix","text":"SwitchMatrix","code":""},{"path":"/reference/SwitchMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change values of HiC map. — SwitchMatrix","text":"","code":"# Data data(HiC_Ctrl.cmx_lst)  # Preprocess HiC HiC.cmx_lst <- HiC_Ctrl.cmx_lst |>     BalanceHiC(         interactionType = \"cis\",         method = \"ICE\"     ) |>     OverExpectedHiC()   # Switch values in matrix HiC_Ctrl_Obs.cmx_lst <- SwitchMatrix(HiC.cmx_lst, matrixKind = \"obs\") HiC_Ctrl_Norm.cmx_lst <- SwitchMatrix(HiC.cmx_lst, matrixKind = \"norm\") HiC_Ctrl_oe.cmx_lst <- SwitchMatrix(HiC.cmx_lst, matrixKind = \"o/e\") #>  #> hicLst is already o/e. HiC_Ctrl_exp.cmx_lst <- SwitchMatrix(HiC.cmx_lst, matrixKind = \"exp\")"},{"path":"/reference/TADs_Domains.gnr.html","id":null,"dir":"Reference","previous_headings":"","what":"D.melanogaster TADs. — TADs_Domains.gnr","title":"D.melanogaster TADs. — TADs_Domains.gnr","text":"Drosophila Melanogaster TADs chromosome 2R 2L (F.Ramirez, 2018)","code":""},{"path":"/reference/TADs_Domains.gnr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"D.melanogaster TADs. — TADs_Domains.gnr","text":"","code":"data(TADs_Domains.gnr)"},{"path":"/reference/TADs_Domains.gnr.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"D.melanogaster TADs. — TADs_Domains.gnr","text":"object class GRanges.","code":""},{"path":"/reference/TADs_Domains.gnr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"D.melanogaster TADs. — TADs_Domains.gnr","text":"","code":"data(TADs_Domains.gnr) TADs_Domains.gnr #> GRanges object with 856 ranges and 3 metadata columns: #>         seqnames            ranges strand |     score       class        name #>            <Rle>         <IRanges>  <Rle> | <numeric> <character> <character> #>     [1]       2L       73104-94543      * |         3      active       Tad_1 #>     [2]       2L      94544-102930      * |         8      active       Tad_2 #>     [3]       2L     102931-121473      * |         8      active       Tad_3 #>     [4]       2L     121474-130495      * |         6      active       Tad_4 #>     [5]       2L     130496-143461      * |         3      active       Tad_5 #>     ...      ...               ...    ... .       ...         ...         ... #>   [852]       2R 24903319-24928487      * |         8      active    Tad_1049 #>   [853]       2R 24938308-24965351      * |         3      active    Tad_1051 #>   [854]       2R 24965352-24969324      * |         8      active    Tad_1052 #>   [855]       2R 24969325-24987568      * |         3      active    Tad_1053 #>   [856]       2R 24987569-25012729      * |         3      active    Tad_1054 #>   ------- #>   seqinfo: 2 sequences from an unspecified genome"},{"path":"/reference/TSS_Peaks.gnr.html","id":null,"dir":"Reference","previous_headings":"","what":"D.melanogaster Transcription starting sites. — TSS_Peaks.gnr","title":"D.melanogaster Transcription starting sites. — TSS_Peaks.gnr","text":"Data CHip Seq experiment","code":""},{"path":"/reference/TSS_Peaks.gnr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"D.melanogaster Transcription starting sites. — TSS_Peaks.gnr","text":"","code":"data(TSS_Peaks.gnr)"},{"path":"/reference/TSS_Peaks.gnr.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"D.melanogaster Transcription starting sites. — TSS_Peaks.gnr","text":"object class GRanges.","code":""},{"path":"/reference/TSS_Peaks.gnr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"D.melanogaster Transcription starting sites. — TSS_Peaks.gnr","text":"","code":"data(TSS_Peaks.gnr) TSS_Peaks.gnr #> GRanges object with 600 ranges and 2 metadata columns: #>         seqnames    ranges strand |       class        name #>            <Rle> <IRanges>  <Rle> | <character> <character> #>     [1]       2L     71757      + |      active FBgn0031213 #>     [2]       2L     76348      + |    inactive FBgn0031214 #>     [3]       2L    106903      + |      active FBgn0005278 #>     [4]       2L    574291      + |      active FBgn0031268 #>     [5]       2L    773547      + |    inactive FBgn0031276 #>     ...      ...       ...    ... .         ...         ... #>   [596]       2R  24768172      - |      active FBgn0027590 #>   [597]       2R  24797414      - |      active FBgn0023181 #>   [598]       2R  24881817      - |    inactive FBgn0263443 #>   [599]       2R  24973207      - |    inactive FBgn0035089 #>   [600]       2R  24975341      - |    inactive FBgn0035090 #>   ------- #>   seqinfo: 2 sequences from an unspecified genome"},{"path":"/reference/TrimOutliers.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove outliers. — TrimOutliers","title":"Remove outliers. — TrimOutliers","text":"Replace values numerical vector minimal thresholds /maximal thresholds.","code":""},{"path":"/reference/TrimOutliers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove outliers. — TrimOutliers","text":"","code":"TrimOutliers(x, thr = SdThreshold(x), clip = FALSE)"},{"path":"/reference/TrimOutliers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove outliers. — TrimOutliers","text":"x : Numeric vector. thr : Numeric vector length 2. first value minimal threshold, second value maximal threshold (Default find threshold based standarrd deviation. see SdThreshold function) clip : TRUE values bounds replaced thresholds values. FALSE Values bound replaced NA (Default FALSE).","code":""},{"path":"/reference/TrimOutliers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove outliers. — TrimOutliers","text":"Trimed Numerical vector.","code":""},{"path":"/reference/TrimOutliers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove outliers. — TrimOutliers","text":"TrimOutliers","code":""},{"path":"/reference/VCnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Vanilla Count Correction. — VCnorm","title":"Compute Vanilla Count Correction. — VCnorm","text":"Compute Vanilla Count Vanilla Count square root correction normalization hic maps.","code":""},{"path":"/reference/VCnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Vanilla Count Correction. — VCnorm","text":"","code":"VCnorm(hic = NULL, qtlTh = 0.15, vcsqrt = TRUE)"},{"path":"/reference/VCnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Vanilla Count Correction. — VCnorm","text":"hic : HiC maps chunk normalize. qtlTh : threshold quantile bins ignored. (Default 0.15) vcsqrt : Whether square root applied. (Default TRUE)","code":""},{"path":"/reference/VCnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Vanilla Count Correction. — VCnorm","text":"matrices list.","code":""},{"path":"/reference/VCnorm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Vanilla Count Correction. — VCnorm","text":"VCnorm","code":""},{"path":"/reference/VCnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Vanilla Count Correction. — VCnorm","text":"","code":"# Data data(HiC_Ctrl.cmx_lst)  HiC_Ctrl_VC.cmx <- VCnorm(HiC_Ctrl.cmx_lst[[\"2L_2L\"]]) HiC_Ctrl_VC_SQRT.cmx <- VCnorm(HiC_Ctrl.cmx_lst[[\"2L_2L\"]], vcsqrt = TRUE)"},{"path":"/reference/WrapFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert string to function. — WrapFunction","title":"Convert string to function. — WrapFunction","text":"Wrap string function.","code":""},{"path":"/reference/WrapFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert string to function. — WrapFunction","text":"","code":"WrapFunction(...)"},{"path":"/reference/WrapFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert string to function. — WrapFunction","text":"... : string parse eval function.","code":""},{"path":"/reference/WrapFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert string to function. — WrapFunction","text":"result function function.","code":""},{"path":"/reference/WrapFunction.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert string to function. — WrapFunction","text":"WrapFunction","code":""},{"path":"/reference/YlGnBu.html","id":null,"dir":"Reference","previous_headings":"","what":"YlGnBu palette. — YlGnBu","title":"YlGnBu palette. — YlGnBu","text":"Create YlGnBu palette.","code":""},{"path":"/reference/YlGnBu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"YlGnBu palette. — YlGnBu","text":"","code":"YlGnBu(   paletteLength = NULL,   space = \"rgb\",   interpolationMethod = \"linear\",   bias = 1 )"},{"path":"/reference/YlGnBu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"YlGnBu palette. — YlGnBu","text":"paletteLength : Color number. space : character string; interpolation RGB CIE Lab color spaces. See ?grDevices::colorRamp details. (Default \"rgb\") interpolationMethod : Use spline linear interpolation. See ?grDevices::colorRamp details. (Default \"linear\") bias : positive number. Higher values give widely spaced colors high end. See ?grDevices::colorRamp details. (Default 1)","code":""},{"path":"/reference/YlGnBu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"YlGnBu palette. — YlGnBu","text":"vector color.","code":""},{"path":"/reference/YlGnBu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"YlGnBu palette. — YlGnBu","text":"YlGnBu","code":""},{"path":"/reference/YlGnBu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"YlGnBu palette. — YlGnBu","text":"","code":"YlGnBu(9) #> [1] \"#FFFFD9\" \"#EDF8B1\" \"#C7E9B4\" \"#7FCDBB\" \"#41B6C4\" \"#1D91C0\" \"#225EA8\" #> [8] \"#253494\" \"#081D58\""},{"path":"/reference/YlOrRd.html","id":null,"dir":"Reference","previous_headings":"","what":"YlOrRd palette. — YlOrRd","title":"YlOrRd palette. — YlOrRd","text":"Create YlOrRd palette.","code":""},{"path":"/reference/YlOrRd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"YlOrRd palette. — YlOrRd","text":"","code":"YlOrRd(   paletteLength = NULL,   space = \"rgb\",   interpolationMethod = \"linear\",   bias = 1 )"},{"path":"/reference/YlOrRd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"YlOrRd palette. — YlOrRd","text":"paletteLength : Color number. space : character string; interpolation RGB CIE Lab color spaces. See ?grDevices::colorRamp details. (Default \"rgb\") interpolationMethod : Use spline linear interpolation. See ?grDevices::colorRamp details. (Default \"linear\") bias : positive number. Higher values give widely spaced colors high end. See ?grDevices::colorRamp details. (Default 1)","code":""},{"path":"/reference/YlOrRd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"YlOrRd palette. — YlOrRd","text":"vector color.","code":""},{"path":"/reference/YlOrRd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"YlOrRd palette. — YlOrRd","text":"YlOrRd","code":""},{"path":"/reference/YlOrRd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"YlOrRd palette. — YlOrRd","text":"","code":"YlOrRd(9) #> [1] \"#FFFFCC\" \"#FFEDA0\" \"#FED976\" \"#FEB24C\" \"#FD8D3C\" \"#FC4E2A\" \"#E31A1C\" #> [8] \"#BD0026\" \"#800026\""},{"path":"/reference/compare_to_background.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes z.test for each target couple over background couples. — compare_to_background","title":"Computes z.test for each target couple over background couples. — compare_to_background","text":"Computes z.test target couple background couples.","code":""},{"path":"/reference/compare_to_background.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes z.test for each target couple over background couples. — compare_to_background","text":"","code":"compare_to_background(   hicList = NULL,   matrices = NULL,   indexAnchor = NULL,   indexBait = NULL,   genomicConstraint = NULL,   secondaryConst.var = NULL,   chromSizes = NULL,   n_background = NULL,   areaFun = \"center\",   operationFun = \"mean\",   bg_type = NULL,   cores = 1,   verbose = FALSE,   p_adj_method = \"BH\",   ... )"},{"path":"/reference/compare_to_background.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes z.test for each target couple over background couples. — compare_to_background","text":"hicList <ListContactMatrix>: HiC maps list. matrices <listmatrix>: matrices list. indexAnchor : first indexed GRanges object used pairs anchor (must indexed using IndexFeatures()). indexBait : second indexed GRanges object used pairs bait (must indexed using IndexFeatures()). genomicConstraint : GRanges object constraint regions. NULL, chromosomes chromSizes used constraints (Default NULL) secondaryConst.var : string defining column name containing compartment information metadata anchor bait  objects. (Default NULL) chromSizes <data.frame>: data.frame containing chromosomes names lengths base pairs. n_background : Number background couples keep. (Default NULL) areaFun : character function allows extract area matrix composes matrices list (Default \"center\"). Look GetQuantif info. operationFun : character function specifying operation applied selected area. (Default \"mean\"). Look GetQuantif info. bg_type : Type background couples generate. Possible choices: \"random_anchors\", \"inter_TAD\", \"inter_compartment\", NULL (Defaults \"random_anchors\"). information details... cores : Number cores used. (Default 1) verbose details progress? (Default: FALSE) p_adj_method method used adjust p.values. stats::p.adjust(). (Default: \"BH\") ... arguments pass PrepareMtxList, inorder treat background matrices.","code":""},{"path":"/reference/compare_to_background.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes z.test for each target couple over background couples. — compare_to_background","text":"returns  object z.test output target couple, values target couples values background couples.","code":""},{"path":"/reference/compare_to_background.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computes z.test for each target couple over background couples. — compare_to_background","text":"Types background couples possible: \"random_anchors\": picks random bins anchors forms couples bait bins. genomicConstraint supplied, intra-TAD random-bait couples kept. Else intra-TAD random-bait couples within distance constraint corresponding minimal maximal distances target couples. \"inter_TAD\": target couples formed using TAD information non NULL genomicConstraint argument, inter-TAD anchor-bait couples used background. Distance constraint applied correspond minimal distance target couples maximal width supplied TADs. \"inter_compartment\": secondaryConst.var NULL indexAnchor indexBait objects contain provided variable name, background couples formed anchors baits located different compartments. \"NULL\": NULL, random_anchors set default. Notes comparison bg target couples: noticed o/e values tend skewed towards long distance interactions. result, long distance background couples tend influence strongly mean sd, resulting long distance target couples significant. rather computing z.score background couples, chosen fit polynomial 2 degrees log(counts) vs distance data background couples. Z.scores computed per target couple comparing residuals target counts predicted model residuals background couples.","code":""},{"path":"/reference/compare_to_background.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes z.test for each target couple over background couples. — compare_to_background","text":"","code":"h5_path <- system.file(\"extdata\",     \"Control_HIC_10k_2L.h5\",     package = \"HicAggR\", mustWork = TRUE ) binSize=10000 data(Beaf32_Peaks.gnr) data(TADs_Domains.gnr) hicLst <- ImportHiC(   file      = h5_path,   hicResolution       = binSize,   chromSizes = data.frame(seqnames = c(\"2L\"),    seqlengths = c(23513712)),   chrom_1   = c(\"2L\") ) hicLst <- BalanceHiC(hicLst) hicLst <- OverExpectedHiC(hicLst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(   gRangeList = list(Beaf = Beaf32_Peaks.gnr),   chromSizes = data.frame(seqnames = c(\"2L\"),     seqlengths = c(23513712)),   genomicConstraint = TADs_Domains.gnr,   binSize = binSize ) Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr)  interactions_Ctrl.mtx_lst <- ExtractSubmatrix(  genomicFeature = Beaf_Beaf.gni,  hicLst = hicLst,  referencePoint = \"pf\" ) interactions_Ctrl.mtx_lst <- PrepareMtxList(  matrices = interactions_Ctrl.mtx_lst ) output_bgInterTAD = compare_to_background(hicList = hicLst,  matrices = interactions_Ctrl.mtx_lst,  indexAnchor = Beaf32_Index.gnr,  indexBait = Beaf32_Index.gnr,  genomicConstraint = TADs_Domains.gnr,  chromSizes = data.frame(seqnames = c(\"2L\"),     seqlengths = c(23513712)),  bg_type=\"inter_TAD\" )"},{"path":"/reference/getInfos.html","id":null,"dir":"Reference","previous_headings":"","what":"get some basic information about your hic file — getInfos","title":"get some basic information about your hic file — getInfos","text":"getInfos","code":""},{"path":"/reference/getInfos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get some basic information about your hic file — getInfos","text":"","code":"getInfos(file = NULL, printInfos = TRUE, returnInfos = FALSE)"},{"path":"/reference/getInfos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get some basic information about your hic file — getInfos","text":"file path file. printInfos print info console? (Default: TRUE) returnInfos return info? (Default: FALSE)","code":""},{"path":"/reference/getInfos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get some basic information about your hic file — getInfos","text":"list characters returnInfos TRUE.","code":""},{"path":"/reference/getInfos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"get some basic information about your hic file — getInfos","text":"","code":"h5_path <- system.file(\"extdata\",     \"Control_HIC_10k_2L.h5\",     package = \"HicAggR\", mustWork = TRUE ) getInfos(h5_path) #> file name: Control_HIC_10k_2L.h5 #> file path: /home/runner/work/_temp/Library/HicAggR/extdata/ #> resolution(s): 10000 #> normalization(s): No correction found! #> unit(s): to be checked #> seqStyle: Ensembl #> chromosom(s): 2L #> chromosom length(s): 23513712"},{"path":"/reference/ggAPA.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregation plot — ggAPA","title":"Aggregation plot — ggAPA","text":"Create ggplot object used plot aggregation.","code":""},{"path":"/reference/ggAPA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregation plot — ggAPA","text":"","code":"ggAPA(   aggregatedMtx = NULL,   title = NULL,   trim = 0,   tails = \"both\",   colMin = NULL,   colMid = NULL,   colMax = NULL,   colBreaks = NULL,   blurPass = 0,   boxKernel = NULL,   kernSize = NULL,   stdev = 0.5,   loTri = NULL,   colors = NULL,   na.value = \"#F2F2F2\",   colorScale = \"linear\",   bias = 1,   paletteLength = 51,   annotate = TRUE,   anchor.name = \"Anchor\",   bait.name = \"Bait\" )"},{"path":"/reference/ggAPA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregation plot — ggAPA","text":"aggregatedMtx : matrix plot. (Default NULL) title : title plot. (Default NULL) trim : number 0 100 gives percentage trimming. (Default 0) tails : boundary must trimmed? , trim half percentage inferior superior. see QtlThreshold. (Default \"\") colMin : Minimal value Heatmap, force color range. NULL automatically find. (Default NULL) colMid : Center value Heatmap, force color range. NULL automatically find. (Default NULL) colMax : Maximal value Heatmap, force color range. NULL automatically find. (Default NULL) colBreaks : Repartition colors. NULL automatically find. (Default NULL) blurPass : Number blur pass. (Default 0) boxKernel : NULL automatically compute 3 Sd. (Default NULL) kernSize : Size box applied blurr. NULL automatically compute 3 Sd. (Default NULL) stdev : SD gaussian smooth. (Default 0.5) loTri : value replace value lower triangle matrice (Usefull blur apply).(Default NULL) colors : Heatmap color list. NULL, automatically compute. (Default NULL) na.value : Color NA values. (Default \"#F2F2F2\") colorScale : Shape color scale \"linear\" \"density\" based. (Default \"linear\") bias : positive number. Higher values give widely spaced colors high end. See ?grDevices::colorRamp details. (Default 1) paletteLength : number color palette. (Default 51) annotate : axis ticks? (Default: TRUE) anchor.name Name anchor annotation. (Default \"Anchor\") bait.name Name bait annotation. (Default \"Bait\")","code":""},{"path":"/reference/ggAPA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregation plot — ggAPA","text":"ggplot object.","code":""},{"path":"/reference/ggAPA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregation plot — ggAPA","text":"ggAPA","code":""},{"path":"/reference/ggAPA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregation plot — ggAPA","text":"","code":"# Data data(Beaf32_Peaks.gnr) data(HiC_Ctrl.cmx_lst)  # Index Beaf32 Beaf32_Index.gnr <- IndexFeatures(     gRangeList = list(Beaf = Beaf32_Peaks.gnr),     chromSizes = data.frame(seqnames = c(\"2L\", \"2R\"),         seqlengths = c(23513712, 25286936)),     binSize = 100000 )  # Beaf32 <-> Beaf32 Pairing Beaf_Beaf.gni <- SearchPairs(indexAnchor = Beaf32_Index.gnr) Beaf_Beaf.gni <- Beaf_Beaf.gni[seq_len(2000)] # subset 2000 first for exemple  # Matrices extractions center on Beaf32 <-> Beaf32 point interaction interactions_PF.mtx_lst <- ExtractSubmatrix(     genomicFeature = Beaf_Beaf.gni,     hicLst = HiC_Ctrl.cmx_lst,     referencePoint = \"pf\" )  # Aggregate matrices in one matrix aggreg.mtx <- Aggregation(interactions_PF.mtx_lst)  # Visualization ggAPA(     aggregatedMtx = aggreg.mtx )   # Add Title ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA\" )   # Trim values ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA 30% trimmed on upper tail of distribution\",     trim = 30,     tails = \"upper\" ) #> Warning: no non-missing arguments to max; returning -Inf  ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA 30% trimmed on lower tail of distribution\",     trim = 30,     tails = \"lower\" ) #> Warning: no non-missing arguments to min; returning Inf  ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA 15% trimmed on each tail of distribution\",     trim = 30,     tails = \"both\" )   # Change Minimal, Central and Maximal Colors scale value ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA [min 200, center 300, max 600]\",     colMin = 200,     colMid = 300,     colMax = 600 )   # Change Color ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA\",     colors = viridis(6),     na.value = \"black\" )  ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA\",     colors = c(\"black\", \"white\"), )   # Change Color distribution ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA [100,150,200,250,300,350,600]\",     colBreaks = c(100, 150, 200, 250, 300, 350, 600) # Choosen Breaks )  ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA\",     colorScale = \"density\" # color distribution based on density )  ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA\",     bias = 2 # (>1 wait on extremums) )  ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA\",     bias = 0.5 # (<1 wait on center) )   # Apply a Blurr ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA\",     blurPass = 1,     stdev = 0.5 )   # ggplot2 object modifications # Since the function returns a ggplot object, it is possible # to modify it following the ggplot2 grammar. ggAPA(     aggregatedMtx = aggreg.mtx,     title = \"APA\", ) +     ggplot2::labs(         title = \"New title\",         subtitle = \"and subtitle\"     )"},{"path":"/reference/import_loops.html","id":null,"dir":"Reference","previous_headings":"","what":"Import called loops in .bedpe format to use in HicAggR — import_loops","title":"Import called loops in .bedpe format to use in HicAggR — import_loops","text":"Imports bedpe file formats GInteractions object usable perform submatrix extraction ExtractSubmatrix()","code":""},{"path":"/reference/import_loops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import called loops in .bedpe format to use in HicAggR — import_loops","text":"","code":"import_loops(   file_bedpe = NULL,   genomicConstraint = NULL,   discard_trans = FALSE,   chromSizes = NULL,   binSize = NULL,   minDist = NULL,   maxDist = NULL,   verbose = FALSE,   cores = 1 )"},{"path":"/reference/import_loops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import called loops in .bedpe format to use in HicAggR — import_loops","text":"file_bedpe bedpe file path (Default NULL) genomicConstraint : GRanges object constraint regions. NULL chromosomes chromSizes used constraints (Default NULL). discard_trans : TRUE discard loops anchor bait different genomic constraint elements, either different TADs chromosomes, genomicConstraint = NULL. (Default FALSE) chromSizes <data.frame>: data.frame containing chromosomes names lengths base pairs (see example). (Default NULL) binSize : Bin size bp - corresponds matrix resolution. minDist : Minimal distance anchors baits. (Default NULL) maxDist : Maximal distance anchors baits. (Default NULL) verbose : Show progression console? (Default FALSE) cores : Number cores use. (Default 1)","code":""},{"path":"/reference/import_loops.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import called loops in .bedpe format to use in HicAggR — import_loops","text":"GInteractions object.","code":""},{"path":"/reference/import_loops.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Import called loops in .bedpe format to use in HicAggR — import_loops","text":"import_loops","code":""},{"path":"/reference/import_loops.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Import called loops in .bedpe format to use in HicAggR — import_loops","text":"","code":"bedpe_path <- system.file(\"extdata\",     \"postprocessed_pixels_5000.bedpe\",     package = \"HicAggR\", mustWork = TRUE ) loops <- import_loops(     file_bedpe = bedpe_path,     chromSizes = data.frame(c(\"1\",\"2\"),         c(249250621,243199373)),     binSize = 5000, minDist = 105000 ) #> Warning: found more than one best sequence renaming map compatible with seqname style \"NCBI\" for this object, using the first one"},{"path":"/reference/viridis.html","id":null,"dir":"Reference","previous_headings":"","what":"viridis palette. — viridis","title":"viridis palette. — viridis","text":"Create viridis palette.","code":""},{"path":"/reference/viridis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"viridis palette. — viridis","text":"","code":"viridis(   paletteLength = NULL,   space = \"rgb\",   interpolationMethod = \"linear\",   bias = 1 )"},{"path":"/reference/viridis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"viridis palette. — viridis","text":"paletteLength : Color number. space : character string; interpolation RGB CIE Lab color spaces. See ?grDevices::colorRamp details. (Default \"rgb\") interpolationMethod : Use spline linear interpolation. See ?grDevices::colorRamp details. (Default \"linear\") bias : positive number. Higher values give widely spaced colors high end. See ?grDevices::colorRamp details. (Default 1)","code":""},{"path":"/reference/viridis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"viridis palette. — viridis","text":"vector color.","code":""},{"path":"/reference/viridis.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"viridis palette. — viridis","text":"viridis","code":""},{"path":"/reference/viridis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"viridis palette. — viridis","text":"","code":"viridis(9) #> [1] \"#440154\" \"#472C7A\" \"#3B518B\" \"#2C718E\" \"#21908C\" \"#27AD80\" \"#5CC862\" #> [8] \"#AADC31\" \"#FDE725\""},{"path":"/news/index.html","id":"hicaggr-0993","dir":"Changelog","previous_headings":"","what":"HicAggR 0.99.3","title":"HicAggR 0.99.3","text":"NAMESPACE generated roxygen2 define exportable functions. compare_to_background: correct skewedness o/e values towards long distances, computation z.scores now calculated using residuals polynomial model fits background couples (log(counts)~distance). SearchPairs: added option remove self interacting bins. internal functions now utilities.R. Docs reviewed.","code":""},{"path":"/news/index.html","id":"hicaggr-0992","dir":"Changelog","previous_headings":"","what":"HicAggR 0.99.2","title":"HicAggR 0.99.2","text":"Implemented import corrected matrices data .hic cool/mcool format. Implemented import O/E matrix data .hic format. Implemented import raw data .h5 format. Added getInfos function get info hic data (.hic, cool/mcool/h5 formats). Removed dependency BSDA::z.test compare_to_background. Removed dependency InteractionSet added package import NAMESPACE remove PackageStartUpMessages. Removed chatty package start message replaced nicer message. BiocCheck NOTES also takedn consideration: changing sapply vapply etc.","code":""},{"path":"/news/index.html","id":"hicaggr-0991","dir":"Changelog","previous_headings":"","what":"HicAggR 0.99.1","title":"HicAggR 0.99.1","text":"Corrected Bioconductor’s reviews Added PrepareMtxList, import_loops, PlotAPA_byDistance & compare_to_background functions Corrected bugs seqlevels consistancy name column GRanges objects Encapsulated small internal functions utilities.R ExtractSubMatrix option remove duplicated submatrices Corrected quantilization operations Aggregation Corrected code suggestions BiocCheck","code":""},{"path":"/news/index.html","id":"hicaggr-0990","dir":"Changelog","previous_headings":"","what":"HicAggR 0.99.0","title":"HicAggR 0.99.0","text":"Submitted Bioconductor","code":""}]
